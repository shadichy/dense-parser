{"version":3,"file":"parser.umd.js","sources":["../node_modules/.pnpm/@emmetio+scanner@1.0.0/node_modules/@emmetio/scanner/scanner.es.js","../node_modules/.pnpm/@emmetio+abbreviation@2.2.3/node_modules/@emmetio/abbreviation/dist/abbreviation.es.js","../node_modules/.pnpm/@emmetio+css-abbreviation@2.1.4/node_modules/@emmetio/css-abbreviation/dist/css-abbreviation.es.js","../node_modules/.pnpm/emmet@2.3.6/node_modules/emmet/dist/emmet.es.js","../src/parser.js"],"sourcesContent":["const defaultQuotedOptions = {\n    escape: 92,\n    throws: false\n};\n/**\n * Check if given code is a number\n */\nfunction isNumber(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n */\nfunction isAlphaNumeric(code) {\n    return isNumber(code) || isAlpha(code);\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha(code);\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @return `true` if quoted string was consumed. The contents of quoted string\n * will be available as `stream.current()`\n */\nfunction eatQuoted(stream, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    const quote = stream.peek();\n    if (stream.eat(isQuote)) {\n        while (!stream.eof()) {\n            switch (stream.next()) {\n                case quote:\n                    stream.start = start;\n                    return true;\n                case options.escape:\n                    stream.next();\n                    break;\n            }\n        }\n        // If we’re here then stream wasn’t properly consumed.\n        // Revert stream and decide what to do\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error('Unable to consume quoted string');\n        }\n    }\n    return false;\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param open Character code of pair opening\n * @param close Character code of pair closing\n * @return Returns `true` if character pair was successfully consumed, it’s\n * content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    if (stream.eat(open)) {\n        let stack = 1;\n        let ch;\n        while (!stream.eof()) {\n            if (eatQuoted(stream, options)) {\n                continue;\n            }\n            ch = stream.next();\n            if (ch === open) {\n                stack++;\n            }\n            else if (ch === close) {\n                stack--;\n                if (!stack) {\n                    stream.start = start;\n                    return true;\n                }\n            }\n            else if (ch === options.escape) {\n                stream.next();\n            }\n        }\n        // If we’re here then paired character can’t be consumed\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n        }\n    }\n    return false;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nexport default Scanner;\nexport { ScannerError, eatPair, eatQuoted, isAlpha, isAlphaNumeric, isAlphaNumericWord, isAlphaWord, isNumber, isQuote, isSpace, isWhiteSpace };\n//# sourceMappingURL=scanner.es.js.map\n","import Scanner, { isAlphaNumericWord, isSpace, isQuote as isQuote$1, isNumber, isAlpha, ScannerError } from '@emmetio/scanner';\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction next(scanner) {\n    return scanner.tokens[scanner.pos++];\n}\nfunction slice(scanner, from = scanner.start, to = scanner.pos) {\n    return scanner.tokens.slice(from, to);\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    const token = peek(scanner);\n    if (token && test(token)) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction abbreviation(abbr, options = {}) {\n    const scanner = tokenScanner(abbr);\n    const result = statements(scanner, options);\n    if (readable(scanner)) {\n        throw error(scanner, 'Unexpected character');\n    }\n    return result;\n}\nfunction statements(scanner, options) {\n    const result = {\n        type: 'TokenGroup',\n        elements: []\n    };\n    let ctx = result;\n    let node;\n    const stack = [];\n    while (readable(scanner)) {\n        if (node = element(scanner, options) || group(scanner, options)) {\n            ctx.elements.push(node);\n            if (consume(scanner, isChildOperator)) {\n                stack.push(ctx);\n                ctx = node;\n            }\n            else if (consume(scanner, isSiblingOperator)) {\n                continue;\n            }\n            else if (consume(scanner, isClimbOperator)) {\n                do {\n                    if (stack.length) {\n                        ctx = stack.pop();\n                    }\n                } while (consume(scanner, isClimbOperator));\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n/**\n * Consumes group from given scanner\n */\nfunction group(scanner, options) {\n    if (consume(scanner, isGroupStart)) {\n        const result = statements(scanner, options);\n        const token = next(scanner);\n        if (isBracket(token, 'group', false)) {\n            result.repeat = repeater(scanner);\n        }\n        return result;\n    }\n}\n/**\n * Consumes single element from given scanner\n */\nfunction element(scanner, options) {\n    let attr;\n    const elem = {\n        type: 'TokenElement',\n        name: void 0,\n        attributes: void 0,\n        value: void 0,\n        repeat: void 0,\n        selfClose: false,\n        elements: []\n    };\n    if (elementName(scanner, options)) {\n        elem.name = slice(scanner);\n    }\n    while (readable(scanner)) {\n        scanner.start = scanner.pos;\n        if (!elem.repeat && !isEmpty(elem) && consume(scanner, isRepeater)) {\n            elem.repeat = scanner.tokens[scanner.pos - 1];\n        }\n        else if (!elem.value && text(scanner)) {\n            elem.value = getText(scanner);\n        }\n        else if (attr = shortAttribute(scanner, 'id', options) || shortAttribute(scanner, 'class', options) || attributeSet(scanner)) {\n            if (!elem.attributes) {\n                elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];\n            }\n            else {\n                elem.attributes = elem.attributes.concat(attr);\n            }\n        }\n        else {\n            if (!isEmpty(elem) && consume(scanner, isCloseOperator)) {\n                elem.selfClose = true;\n                if (!elem.repeat && consume(scanner, isRepeater)) {\n                    elem.repeat = scanner.tokens[scanner.pos - 1];\n                }\n            }\n            break;\n        }\n    }\n    return !isEmpty(elem) ? elem : void 0;\n}\n/**\n * Consumes attribute set from given scanner\n */\nfunction attributeSet(scanner) {\n    if (consume(scanner, isAttributeSetStart)) {\n        const attributes = [];\n        let attr;\n        while (readable(scanner)) {\n            if (attr = attribute(scanner)) {\n                attributes.push(attr);\n            }\n            else if (consume(scanner, isAttributeSetEnd)) {\n                break;\n            }\n            else if (!consume(scanner, isWhiteSpace)) {\n                throw error(scanner, `Unexpected \"${peek(scanner).type}\" token`);\n            }\n        }\n        return attributes;\n    }\n}\n/**\n * Consumes attribute shorthand (class or id) from given scanner\n */\nfunction shortAttribute(scanner, type, options) {\n    if (isOperator(peek(scanner), type)) {\n        scanner.pos++;\n        const attr = {\n            name: [createLiteral(type)]\n        };\n        // Consume expression after shorthand start for React-like components\n        if (options.jsx && text(scanner)) {\n            attr.value = getText(scanner);\n            attr.expression = true;\n        }\n        else {\n            attr.value = literal(scanner) ? slice(scanner) : void 0;\n        }\n        return attr;\n    }\n}\n/**\n * Consumes single attribute from given scanner\n */\nfunction attribute(scanner) {\n    if (quoted(scanner)) {\n        // Consumed quoted value: it’s a value for default attribute\n        return {\n            value: slice(scanner)\n        };\n    }\n    if (literal(scanner, true)) {\n        return {\n            name: slice(scanner),\n            value: consume(scanner, isEquals) && (quoted(scanner) || literal(scanner, true))\n                ? slice(scanner)\n                : void 0\n        };\n    }\n}\nfunction repeater(scanner) {\n    return isRepeater(peek(scanner))\n        ? scanner.tokens[scanner.pos++]\n        : void 0;\n}\n/**\n * Consumes quoted value from given scanner, if possible\n */\nfunction quoted(scanner) {\n    const start = scanner.pos;\n    const quote = peek(scanner);\n    if (isQuote(quote)) {\n        scanner.pos++;\n        while (readable(scanner)) {\n            if (isQuote(next(scanner), quote.single)) {\n                scanner.start = start;\n                return true;\n            }\n        }\n        throw error(scanner, 'Unclosed quote', quote);\n    }\n    return false;\n}\n/**\n * Consumes literal (unquoted value) from given scanner\n */\nfunction literal(scanner, allowBrackets) {\n    const start = scanner.pos;\n    const brackets = {\n        attribute: 0,\n        expression: 0,\n        group: 0\n    };\n    while (readable(scanner)) {\n        const token = peek(scanner);\n        if (brackets.expression) {\n            // If we’re inside expression, we should consume all content in it\n            if (isBracket(token, 'expression')) {\n                brackets[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else if (isQuote(token) || isOperator(token) || isWhiteSpace(token) || isRepeater(token)) {\n            break;\n        }\n        else if (isBracket(token)) {\n            if (!allowBrackets) {\n                break;\n            }\n            if (token.open) {\n                brackets[token.context]++;\n            }\n            else if (!brackets[token.context]) {\n                // Stop if found unmatched closing brace: it must be handled\n                // by parent consumer\n                break;\n            }\n            else {\n                brackets[token.context]--;\n            }\n        }\n        scanner.pos++;\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes element name from given scanner\n */\nfunction elementName(scanner, options) {\n    const start = scanner.pos;\n    if (options.jsx && consume(scanner, isCapitalizedLiteral)) {\n        // Check for edge case: consume immediate capitalized class names\n        // for React-like components, e.g. `Foo.Bar.Baz`\n        while (readable(scanner)) {\n            const { pos } = scanner;\n            if (!consume(scanner, isClassNameOperator) || !consume(scanner, isCapitalizedLiteral)) {\n                scanner.pos = pos;\n                break;\n            }\n        }\n    }\n    while (readable(scanner) && consume(scanner, isElementName)) {\n        // empty\n    }\n    if (scanner.pos !== start) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes text value from given scanner\n */\nfunction text(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isTextStart)) {\n        let brackets = 0;\n        while (readable(scanner)) {\n            const token = next(scanner);\n            if (isBracket(token, 'expression')) {\n                if (token.open) {\n                    brackets++;\n                }\n                else if (!brackets) {\n                    break;\n                }\n                else {\n                    brackets--;\n                }\n            }\n        }\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\nfunction getText(scanner) {\n    let from = scanner.start;\n    let to = scanner.pos;\n    if (isBracket(scanner.tokens[from], 'expression', true)) {\n        from++;\n    }\n    if (isBracket(scanner.tokens[to - 1], 'expression', false)) {\n        to--;\n    }\n    return slice(scanner, from, to);\n}\nfunction isBracket(token, context, isOpen) {\n    return Boolean(token && token.type === 'Bracket'\n        && (!context || token.context === context)\n        && (isOpen == null || token.open === isOpen));\n}\nfunction isOperator(token, type) {\n    return Boolean(token && token.type === 'Operator' && (!type || token.operator === type));\n}\nfunction isQuote(token, isSingle) {\n    return Boolean(token && token.type === 'Quote' && (isSingle == null || token.single === isSingle));\n}\nfunction isWhiteSpace(token) {\n    return Boolean(token && token.type === 'WhiteSpace');\n}\nfunction isEquals(token) {\n    return isOperator(token, 'equal');\n}\nfunction isRepeater(token) {\n    return Boolean(token && token.type === 'Repeater');\n}\nfunction isLiteral(token) {\n    return token.type === 'Literal';\n}\nfunction isCapitalizedLiteral(token) {\n    if (isLiteral(token)) {\n        const ch = token.value.charCodeAt(0);\n        return ch >= 65 && ch <= 90;\n    }\n    return false;\n}\nfunction isElementName(token) {\n    return token.type === 'Literal' || token.type === 'RepeaterNumber' || token.type === 'RepeaterPlaceholder';\n}\nfunction isClassNameOperator(token) {\n    return isOperator(token, 'class');\n}\nfunction isAttributeSetStart(token) {\n    return isBracket(token, 'attribute', true);\n}\nfunction isAttributeSetEnd(token) {\n    return isBracket(token, 'attribute', false);\n}\nfunction isTextStart(token) {\n    return isBracket(token, 'expression', true);\n}\nfunction isGroupStart(token) {\n    return isBracket(token, 'group', true);\n}\nfunction createLiteral(value) {\n    return { type: 'Literal', value };\n}\nfunction isEmpty(elem) {\n    return !elem.name && !elem.value && !elem.attributes;\n}\nfunction isChildOperator(token) {\n    return isOperator(token, 'child');\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, 'sibling');\n}\nfunction isClimbOperator(token) {\n    return isOperator(token, 'climb');\n}\nfunction isCloseOperator(token) {\n    return isOperator(token, 'close');\n}\n\n/**\n * If consumes escape character, sets current stream range to escaped value\n */\nfunction escaped(scanner) {\n    if (scanner.eat(92 /* Escape */)) {\n        scanner.start = scanner.pos;\n        if (!scanner.eof()) {\n            scanner.pos++;\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction tokenize(source) {\n    const scanner = new Scanner(source);\n    const result = [];\n    const ctx = {\n        group: 0,\n        attribute: 0,\n        expression: 0,\n        quote: 0\n    };\n    let ch = 0;\n    let token;\n    while (!scanner.eof()) {\n        ch = scanner.peek();\n        token = getToken(scanner, ctx);\n        if (token) {\n            result.push(token);\n            if (token.type === 'Quote') {\n                ctx.quote = ch === ctx.quote ? 0 : ch;\n            }\n            else if (token.type === 'Bracket') {\n                ctx[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else {\n            throw scanner.error('Unexpected character');\n        }\n    }\n    return result;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, ctx) {\n    return field(scanner, ctx)\n        || repeaterPlaceholder(scanner)\n        || repeaterNumber(scanner)\n        || repeater$1(scanner)\n        || whiteSpace(scanner)\n        || literal$1(scanner, ctx)\n        || operator(scanner)\n        || quote(scanner)\n        || bracket(scanner);\n}\n/**\n * Consumes literal from given scanner\n */\nfunction literal$1(scanner, ctx) {\n    const start = scanner.pos;\n    let value = '';\n    while (!scanner.eof()) {\n        // Consume escaped sequence no matter of context\n        if (escaped(scanner)) {\n            value += scanner.current();\n            continue;\n        }\n        const ch = scanner.peek();\n        if (ch === ctx.quote || ch === 36 /* Dollar */ || isAllowedOperator(ch, ctx)) {\n            // 1. Found matching quote\n            // 2. The `$` character has special meaning in every context\n            // 3. Depending on context, some characters should be treated as operators\n            break;\n        }\n        if (ctx.expression && ch === 125 /* CurlyBracketClose */) {\n            break;\n        }\n        if (!ctx.quote && !ctx.expression) {\n            // Consuming element name\n            if (!ctx.attribute && !isElementName$1(ch)) {\n                break;\n            }\n            if (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote$1(ch) || bracketType(ch)) {\n                // Stop for characters not allowed in unquoted literal\n                break;\n            }\n        }\n        value += scanner.string[scanner.pos++];\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return {\n            type: 'Literal',\n            value,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos,\n            value: scanner.substring(start, scanner.pos)\n        };\n    }\n}\n/**\n * Consumes quote from given scanner\n */\nfunction quote(scanner) {\n    const ch = scanner.peek();\n    if (isQuote$1(ch)) {\n        return {\n            type: 'Quote',\n            single: ch === 39 /* SingleQuote */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    const context = bracketType(ch);\n    if (context) {\n        return {\n            type: 'Bracket',\n            open: isOpenBracket(ch),\n            context,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n */\nfunction repeater$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(42 /* Asterisk */)) {\n        scanner.start = scanner.pos;\n        let count = 1;\n        let implicit = false;\n        if (scanner.eatWhile(isNumber)) {\n            count = Number(scanner.current());\n        }\n        else {\n            implicit = true;\n        }\n        return {\n            type: 'Repeater',\n            count,\n            value: 0,\n            implicit,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes repeater placeholder `$#` from given scanner\n */\nfunction repeaterPlaceholder(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(35 /* Hash */)) {\n        return {\n            type: 'RepeaterPlaceholder',\n            value: void 0,\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes numbering token like `$` from given scanner state\n */\nfunction repeaterNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(36 /* Dollar */)) {\n        const size = scanner.pos - start;\n        let reverse = false;\n        let base = 1;\n        let parent = 0;\n        if (scanner.eat(64 /* At */)) {\n            // Consume numbering modifiers\n            while (scanner.eat(94 /* Climb */)) {\n                parent++;\n            }\n            reverse = scanner.eat(45 /* Dash */);\n            scanner.start = scanner.pos;\n            if (scanner.eatWhile(isNumber)) {\n                base = Number(scanner.current());\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'RepeaterNumber',\n            size,\n            reverse,\n            base,\n            parent,\n            start,\n            end: scanner.pos\n        };\n    }\n}\nfunction field(scanner, ctx) {\n    const start = scanner.pos;\n    // Fields are allowed inside expressions and attributes\n    if ((ctx.expression || ctx.attribute) && scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Check if given character code is an operator and it’s allowed in current context\n */\nfunction isAllowedOperator(ch, ctx) {\n    const op = operatorType(ch);\n    if (!op || ctx.quote || ctx.expression) {\n        // No operators inside quoted values or expressions\n        return false;\n    }\n    // Inside attributes, only `equals` is allowed\n    return !ctx.attribute || op === 'equal';\n}\n/**\n * Check if given character is a space character and is allowed to be consumed\n * as a space token in current context\n */\nfunction isAllowedSpace(ch, ctx) {\n    return isSpace(ch) && !ctx.expression;\n}\n/**\n * Check if given character can be consumed as repeater in current context\n */\nfunction isAllowedRepeater(ch, ctx) {\n    return ch === 42 /* Asterisk */ && !ctx.attribute && !ctx.expression;\n}\n/**\n * If given character is a bracket, returns it’s type\n */\nfunction bracketType(ch) {\n    if (ch === 40 /* RoundBracketOpen */ || ch === 41 /* RoundBracketClose */) {\n        return 'group';\n    }\n    if (ch === 91 /* SquareBracketOpen */ || ch === 93 /* SquareBracketClose */) {\n        return 'attribute';\n    }\n    if (ch === 123 /* CurlyBracketOpen */ || ch === 125 /* CurlyBracketClose */) {\n        return 'expression';\n    }\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 62 /* Child */ && 'child')\n        || (ch === 43 /* Sibling */ && 'sibling')\n        || (ch === 94 /* Climb */ && 'climb')\n        || (ch === 46 /* Dot */ && 'class')\n        || (ch === 35 /* Hash */ && 'id')\n        || (ch === 47 /* Slash */ && 'close')\n        || (ch === 61 /* Equals */ && 'equal')\n        || void 0;\n}\n/**\n * Check if given character is an open bracket\n */\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyBracketOpen */\n        || ch === 91 /* SquareBracketOpen */\n        || ch === 40 /* RoundBracketOpen */;\n}\n/**\n * Check if given character is allowed in element name\n */\nfunction isElementName$1(ch) {\n    return isAlphaNumericWord(ch)\n        || ch === 45 /* Dash */\n        || ch === 58 /* Colon */\n        || ch === 33 /* Excl */;\n}\n\nconst operators = {\n    child: '>',\n    class: '.',\n    climb: '^',\n    id: '#',\n    equal: '=',\n    close: '/',\n    sibling: '+'\n};\nconst tokenVisitor = {\n    Literal(token) {\n        return token.value;\n    },\n    Quote(token) {\n        return token.single ? '\\'' : '\"';\n    },\n    Bracket(token) {\n        if (token.context === 'attribute') {\n            return token.open ? '[' : ']';\n        }\n        else if (token.context === 'expression') {\n            return token.open ? '{' : '}';\n        }\n        else {\n            return token.open ? '(' : '}';\n        }\n    },\n    Operator(token) {\n        return operators[token.operator];\n    },\n    Field(token, state) {\n        if (token.index != null) {\n            // It’s a field: by default, return TextMate-compatible field\n            return token.name\n                ? `\\${${token.index}:${token.name}}`\n                : `\\${${token.index}`;\n        }\n        else if (token.name) {\n            // It’s a variable\n            return state.getVariable(token.name);\n        }\n        return '';\n    },\n    RepeaterPlaceholder(token, state) {\n        // Find closest implicit repeater\n        let repeater;\n        for (let i = state.repeaters.length - 1; i >= 0; i--) {\n            if (state.repeaters[i].implicit) {\n                repeater = state.repeaters[i];\n                break;\n            }\n        }\n        state.inserted = true;\n        return state.getText(repeater && repeater.value);\n    },\n    RepeaterNumber(token, state) {\n        let value = 1;\n        const lastIx = state.repeaters.length - 1;\n        // const repeaterIx = Math.max(0, state.repeaters.length - 1 - token.parent);\n        const repeater = state.repeaters[lastIx];\n        if (repeater) {\n            value = token.reverse\n                ? token.base + repeater.count - repeater.value - 1\n                : token.base + repeater.value;\n            if (token.parent) {\n                const parentIx = Math.max(0, lastIx - token.parent);\n                if (parentIx !== lastIx) {\n                    const parentRepeater = state.repeaters[parentIx];\n                    value += repeater.count * parentRepeater.value;\n                }\n            }\n        }\n        let result = String(value);\n        while (result.length < token.size) {\n            result = '0' + result;\n        }\n        return result;\n    },\n    WhiteSpace(token) {\n        return token.value;\n    }\n};\n/**\n * Converts given value token to string\n */\nfunction stringify(token, state) {\n    if (!tokenVisitor[token.type]) {\n        throw new Error(`Unknown token ${token.type}`);\n    }\n    return tokenVisitor[token.type](token, state);\n}\n\nconst urlRegex = /^((https?:|ftp:|file:)?\\/\\/|(www|ftp)\\.)[^ ]*$/;\nconst emailRegex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,5}$/;\n/**\n * Converts given token-based abbreviation into simplified and unrolled node-based\n * abbreviation\n */\nfunction convert(abbr, options = {}) {\n    let textInserted = false;\n    let cleanText;\n    if (options.text) {\n        if (Array.isArray(options.text)) {\n            cleanText = options.text.filter(s => s.trim());\n        }\n        else {\n            cleanText = options.text;\n        }\n    }\n    const result = {\n        type: 'Abbreviation',\n        children: convertGroup(abbr, {\n            inserted: false,\n            repeaters: [],\n            text: options.text,\n            cleanText,\n            repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,\n            getText(pos) {\n                var _a;\n                textInserted = true;\n                let value;\n                if (Array.isArray(options.text)) {\n                    if (pos !== undefined && pos >= 0 && pos < cleanText.length) {\n                        return cleanText[pos];\n                    }\n                    value = pos !== undefined ? options.text[pos] : options.text.join('\\n');\n                }\n                else {\n                    value = (_a = options.text) !== null && _a !== void 0 ? _a : '';\n                }\n                return value;\n            },\n            getVariable(name) {\n                const varValue = options.variables && options.variables[name];\n                return varValue != null ? varValue : name;\n            }\n        })\n    };\n    if (options.text != null && !textInserted) {\n        // Text given but no implicitly repeated elements: insert it into\n        // deepest child\n        const deepest = deepestNode(last(result.children));\n        if (deepest) {\n            const text = Array.isArray(options.text) ? options.text.join('\\n') : options.text;\n            insertText(deepest, text);\n            if (deepest.name === 'a' && options.href) {\n                // Automatically update value of `<a>` element if inserting URL or email\n                insertHref(deepest, text);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Converts given statement to abbreviation nodes\n */\nfunction convertStatement(node, state) {\n    let result = [];\n    if (node.repeat) {\n        // Node is repeated: we should create copies of given node\n        // and supply context token with actual repeater state\n        const original = node.repeat;\n        const repeat = Object.assign({}, original);\n        repeat.count = repeat.implicit && Array.isArray(state.text)\n            ? state.cleanText.length\n            : (repeat.count || 1);\n        let items;\n        state.repeaters.push(repeat);\n        for (let i = 0; i < repeat.count; i++) {\n            repeat.value = i;\n            node.repeat = repeat;\n            items = isGroup(node)\n                ? convertGroup(node, state)\n                : convertElement(node, state);\n            if (repeat.implicit && !state.inserted) {\n                // It’s an implicit repeater but no repeater placeholders found inside,\n                // we should insert text into deepest node\n                const target = last(items);\n                const deepest = target && deepestNode(target);\n                if (deepest) {\n                    insertText(deepest, state.getText(repeat.value));\n                }\n            }\n            result = result.concat(items);\n            // We should output at least one repeated item even if it’s reached\n            // repeat limit\n            if (--state.repeatGuard <= 0) {\n                break;\n            }\n        }\n        state.repeaters.pop();\n        node.repeat = original;\n        if (repeat.implicit) {\n            state.inserted = true;\n        }\n    }\n    else {\n        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));\n    }\n    return result;\n}\nfunction convertElement(node, state) {\n    let children = [];\n    const elem = {\n        type: 'AbbreviationNode',\n        name: node.name && stringifyName(node.name, state),\n        value: node.value && stringifyValue(node.value, state),\n        attributes: void 0,\n        children,\n        repeat: node.repeat && Object.assign({}, node.repeat),\n        selfClosing: node.selfClose,\n    };\n    let result = [elem];\n    for (const child of node.elements) {\n        children = children.concat(convertStatement(child, state));\n    }\n    if (node.attributes) {\n        elem.attributes = [];\n        for (const attr of node.attributes) {\n            elem.attributes.push(convertAttribute(attr, state));\n        }\n    }\n    // In case if current node is a text-only snippet without fields, we should\n    // put all children as siblings\n    if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField)) {\n        // XXX it’s unclear that `children` is not bound to `elem`\n        // due to concat operation\n        result = result.concat(children);\n    }\n    else {\n        elem.children = children;\n    }\n    return result;\n}\nfunction convertGroup(node, state) {\n    let result = [];\n    for (const child of node.elements) {\n        result = result.concat(convertStatement(child, state));\n    }\n    if (node.repeat) {\n        result = attachRepeater(result, node.repeat);\n    }\n    return result;\n}\nfunction convertAttribute(node, state) {\n    let implied = false;\n    let isBoolean = false;\n    let valueType = node.expression ? 'expression' : 'raw';\n    let value;\n    const name = node.name && stringifyName(node.name, state);\n    if (name && name[0] === '!') {\n        implied = true;\n    }\n    if (name && name[name.length - 1] === '.') {\n        isBoolean = true;\n    }\n    if (node.value) {\n        const tokens = node.value.slice();\n        if (isQuote(tokens[0])) {\n            // It’s a quoted value: remove quotes from output but mark attribute\n            // value as quoted\n            const quote = tokens.shift();\n            if (tokens.length && last(tokens).type === quote.type) {\n                tokens.pop();\n            }\n            valueType = quote.single ? 'singleQuote' : 'doubleQuote';\n        }\n        else if (isBracket(tokens[0], 'expression', true)) {\n            // Value is expression: remove brackets but mark value type\n            valueType = 'expression';\n            tokens.shift();\n            if (isBracket(last(tokens), 'expression', false)) {\n                tokens.pop();\n            }\n        }\n        value = stringifyValue(tokens, state);\n    }\n    return {\n        name: isBoolean || implied\n            ? name.slice(implied ? 1 : 0, isBoolean ? -1 : void 0)\n            : name,\n        value,\n        boolean: isBoolean,\n        implied,\n        valueType\n    };\n}\n/**\n * Converts given token list to string\n */\nfunction stringifyName(tokens, state) {\n    let str = '';\n    for (let i = 0; i < tokens.length; i++) {\n        str += stringify(tokens[i], state);\n    }\n    return str;\n}\n/**\n * Converts given token list to value list\n */\nfunction stringifyValue(tokens, state) {\n    const result = [];\n    let str = '';\n    for (let i = 0, token; i < tokens.length; i++) {\n        token = tokens[i];\n        if (isField(token)) {\n            // We should keep original fields in output since some editors has their\n            // own syntax for field or doesn’t support fields at all so we should\n            // capture actual field location in output stream\n            if (str) {\n                result.push(str);\n                str = '';\n            }\n            result.push(token);\n        }\n        else {\n            str += stringify(token, state);\n        }\n    }\n    if (str) {\n        result.push(str);\n    }\n    return result;\n}\nfunction isGroup(node) {\n    return node.type === 'TokenGroup';\n}\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field' && token.index != null;\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nfunction deepestNode(node) {\n    return node.children.length ? deepestNode(last(node.children)) : node;\n}\nfunction insertText(node, text) {\n    if (node.value) {\n        const lastToken = last(node.value);\n        if (typeof lastToken === 'string') {\n            node.value[node.value.length - 1] += text;\n        }\n        else {\n            node.value.push(text);\n        }\n    }\n    else {\n        node.value = [text];\n    }\n}\nfunction insertHref(node, text) {\n    var _a;\n    let href = '';\n    if (urlRegex.test(text)) {\n        href = text;\n        if (!/\\w+:/.test(href) && !href.startsWith('//')) {\n            href = `http://${href}`;\n        }\n    }\n    else if (emailRegex.test(text)) {\n        href = `mailto:${text}`;\n    }\n    const hrefAttribute = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.find(attr => attr.name === 'href');\n    if (!hrefAttribute) {\n        if (!node.attributes) {\n            node.attributes = [];\n        }\n        node.attributes.push({ name: 'href', value: [href], valueType: 'doubleQuote' });\n    }\n    else if (!hrefAttribute.value) {\n        hrefAttribute.value = [href];\n    }\n}\nfunction attachRepeater(items, repeater) {\n    for (const item of items) {\n        if (!item.repeat) {\n            item.repeat = Object.assign({}, repeater);\n        }\n    }\n    return items;\n}\n\n/**\n * Parses given abbreviation into node tree\n */\nfunction parseAbbreviation(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr) : abbr;\n        return convert(abbreviation(tokens, options), options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport default parseAbbreviation;\nexport { convert, getToken, abbreviation as parse, tokenize };\n//# sourceMappingURL=abbreviation.es.js.map\n","import Scanner, { isNumber, isAlpha, isAlphaWord, isQuote, isSpace, isAlphaNumericWord, ScannerError } from '@emmetio/scanner';\n\nfunction tokenize(abbr, isValue) {\n    let brackets = 0;\n    let token;\n    const scanner = new Scanner(abbr);\n    const tokens = [];\n    while (!scanner.eof()) {\n        token = getToken(scanner, brackets === 0 && !isValue);\n        if (!token) {\n            throw scanner.error('Unexpected character');\n        }\n        if (token.type === 'Bracket') {\n            if (!brackets && token.open) {\n                mergeTokens(scanner, tokens);\n            }\n            brackets += token.open ? 1 : -1;\n            if (brackets < 0) {\n                throw scanner.error('Unexpected bracket', token.start);\n            }\n        }\n        tokens.push(token);\n        // Forcibly consume next operator after unit-less numeric value or color:\n        // next dash `-` must be used as value delimiter\n        if (shouldConsumeDashAfter(token) && (token = operator(scanner))) {\n            tokens.push(token);\n        }\n    }\n    return tokens;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, short) {\n    return field(scanner)\n        || numberValue(scanner)\n        || colorValue(scanner)\n        || stringValue(scanner)\n        || bracket(scanner)\n        || operator(scanner)\n        || whiteSpace(scanner)\n        || literal(scanner, short);\n}\nfunction field(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Consumes literal from given scanner\n * @param short Use short notation for consuming value.\n * The difference between “short” and “full” notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while “full” notation also supports numbers and dashes\n */\nfunction literal(scanner, short) {\n    const start = scanner.pos;\n    if (scanner.eat(isIdentPrefix)) {\n        // SCSS or LESS variable\n        // NB a bit dirty hack: if abbreviation starts with identifier prefix,\n        // consume alpha characters only to allow embedded variables\n        scanner.eatWhile(start ? isKeyword : isLiteral);\n    }\n    else if (scanner.eat(isAlphaWord)) {\n        scanner.eatWhile(short ? isLiteral : isKeyword);\n    }\n    else {\n        // Allow dots only at the beginning of literal\n        scanner.eat(46 /* Dot */);\n        scanner.eatWhile(isLiteral);\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return createLiteral(scanner, scanner.start = start);\n    }\n}\nfunction createLiteral(scanner, start = scanner.start, end = scanner.pos) {\n    return {\n        type: 'Literal',\n        value: scanner.substring(start, end),\n        start,\n        end\n    };\n}\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n */\nfunction numberValue(scanner) {\n    const start = scanner.pos;\n    if (consumeNumber(scanner)) {\n        scanner.start = start;\n        const rawValue = scanner.current();\n        // eat unit, which can be a % or alpha word\n        scanner.start = scanner.pos;\n        scanner.eat(37 /* Percent */) || scanner.eatWhile(isAlphaWord);\n        return {\n            type: 'NumberValue',\n            value: Number(rawValue),\n            rawValue,\n            unit: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quoted string value from given scanner\n */\nfunction stringValue(scanner) {\n    const ch = scanner.peek();\n    const start = scanner.pos;\n    let finished = false;\n    if (isQuote(ch)) {\n        scanner.pos++;\n        while (!scanner.eof()) {\n            // Do not throw error on malformed string\n            if (scanner.eat(ch)) {\n                finished = true;\n                break;\n            }\n            else {\n                scanner.pos++;\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'StringValue',\n            value: scanner.substring(start + 1, scanner.pos - (finished ? 1 : 0)),\n            quote: ch === 39 /* SingleQuote */ ? 'single' : 'double',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes a color token from given string\n */\nfunction colorValue(scanner) {\n    // supported color variations:\n    // #abc   → #aabbccc\n    // #0     → #000000\n    // #fff.5 → rgba(255, 255, 255, 0.5)\n    // #t     → transparent\n    const start = scanner.pos;\n    if (scanner.eat(35 /* Hash */)) {\n        const valueStart = scanner.pos;\n        let color = '';\n        let alpha = '';\n        if (scanner.eatWhile(isHex)) {\n            color = scanner.substring(valueStart, scanner.pos);\n            alpha = colorAlpha(scanner);\n        }\n        else if (scanner.eat(116 /* Transparent */)) {\n            color = '0';\n            alpha = colorAlpha(scanner) || '0';\n        }\n        else {\n            alpha = colorAlpha(scanner);\n        }\n        if (color || alpha || scanner.eof()) {\n            const { r, g, b, a } = parseColor(color, alpha);\n            return {\n                type: 'ColorValue',\n                r, g, b, a,\n                raw: scanner.substring(start + 1, scanner.pos),\n                start,\n                end: scanner.pos\n            };\n        }\n        else {\n            // Consumed # but no actual value: invalid color value, treat it as literal\n            return createLiteral(scanner, start);\n        }\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes alpha value of color: `.1`\n */\nfunction colorAlpha(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(46 /* Dot */)) {\n        scanner.start = start;\n        if (scanner.eatWhile(isNumber)) {\n            return scanner.current();\n        }\n        return '1';\n    }\n    return '';\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    if (isBracket(ch)) {\n        return {\n            type: 'Bracket',\n            open: ch === 40 /* RoundBracketOpen */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Eats number value from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(stream) {\n    const start = stream.pos;\n    stream.eat(45 /* Dash */);\n    const afterNegative = stream.pos;\n    const hasDecimal = stream.eatWhile(isNumber);\n    const prevPos = stream.pos;\n    if (stream.eat(46 /* Dot */)) {\n        // It’s perfectly valid to have numbers like `1.`, which enforces\n        // value to float unit type\n        const hasFloat = stream.eatWhile(isNumber);\n        if (!hasDecimal && !hasFloat) {\n            // Lone dot\n            stream.pos = prevPos;\n        }\n    }\n    // Edge case: consumed dash only: not a number, bail-out\n    if (stream.pos === afterNegative) {\n        stream.pos = start;\n    }\n    return stream.pos !== start;\n}\nfunction isIdentPrefix(code) {\n    return code === 64 /* At */ || code === 36 /* Dollar */;\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 43 /* Sibling */ && \"+\" /* Sibling */)\n        || (ch === 33 /* Excl */ && \"!\" /* Important */)\n        || (ch === 44 /* Comma */ && \",\" /* ArgumentDelimiter */)\n        || (ch === 58 /* Colon */ && \":\" /* PropertyDelimiter */)\n        || (ch === 45 /* Dash */ && \"-\" /* ValueDelimiter */)\n        || void 0;\n}\n/**\n * Check if given code is a hex value (/0-9a-f/)\n */\nfunction isHex(code) {\n    return isNumber(code) || isAlpha(code, 65, 70); // A-F\n}\nfunction isKeyword(code) {\n    return isAlphaNumericWord(code) || code === 45 /* Dash */;\n}\nfunction isBracket(code) {\n    return code === 40 /* RoundBracketOpen */ || code === 41 /* RoundBracketClose */;\n}\nfunction isLiteral(code) {\n    return isAlphaWord(code) || code === 37 /* Percent */ || code === 47 /* Slash */;\n}\n/**\n * Parses given color value from abbreviation into RGBA format\n */\nfunction parseColor(value, alpha) {\n    let r = '0';\n    let g = '0';\n    let b = '0';\n    let a = Number(alpha != null && alpha !== '' ? alpha : 1);\n    if (value === 't') {\n        a = 0;\n    }\n    else {\n        switch (value.length) {\n            case 0:\n                break;\n            case 1:\n                r = g = b = value + value;\n                break;\n            case 2:\n                r = g = b = value;\n                break;\n            case 3:\n                r = value[0] + value[0];\n                g = value[1] + value[1];\n                b = value[2] + value[2];\n                break;\n            default:\n                value += value;\n                r = value.slice(0, 2);\n                g = value.slice(2, 4);\n                b = value.slice(4, 6);\n        }\n    }\n    return {\n        r: parseInt(r, 16),\n        g: parseInt(g, 16),\n        b: parseInt(b, 16),\n        a\n    };\n}\n/**\n * Check if scanner reader must consume dash after given token.\n * Used in cases where user must explicitly separate numeric values\n */\nfunction shouldConsumeDashAfter(token) {\n    return token.type === 'ColorValue' || (token.type === 'NumberValue' && !token.unit);\n}\n/**\n * Merges last adjacent tokens into a single literal.\n * This function is used to overcome edge case when function name was parsed\n * as a list of separate tokens. For example, a `scale3d()` value will be\n * parsed as literal and number tokens (`scale` and `3d`) which is a perfectly\n * valid abbreviation but undesired result. This function will detect last adjacent\n * literal and number values and combine them into single literal\n */\nfunction mergeTokens(scanner, tokens) {\n    let start = 0;\n    let end = 0;\n    while (tokens.length) {\n        const token = last(tokens);\n        if (token.type === 'Literal' || token.type === 'NumberValue') {\n            start = token.start;\n            if (!end) {\n                end = token.end;\n            }\n            tokens.pop();\n        }\n        else {\n            break;\n        }\n    }\n    if (start !== end) {\n        tokens.push(createLiteral(scanner, start, end));\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    if (test(peek(scanner))) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction parser(tokens, options = {}) {\n    const scanner = tokenScanner(tokens);\n    const result = [];\n    let property;\n    while (readable(scanner)) {\n        if (property = consumeProperty(scanner, options)) {\n            result.push(property);\n        }\n        else if (!consume(scanner, isSiblingOperator)) {\n            throw error(scanner, 'Unexpected token');\n        }\n    }\n    return result;\n}\n/**\n * Consumes single CSS property\n */\nfunction consumeProperty(scanner, options) {\n    let name;\n    let important = false;\n    let valueFragment;\n    const value = [];\n    const token = peek(scanner);\n    const valueMode = !!options.value;\n    if (!valueMode && isLiteral$1(token) && !isFunctionStart(scanner)) {\n        scanner.pos++;\n        name = token.value;\n        // Consume any following value delimiter after property name\n        consume(scanner, isValueDelimiter);\n    }\n    // Skip whitespace right after property name, if any\n    if (valueMode) {\n        consume(scanner, isWhiteSpace);\n    }\n    while (readable(scanner)) {\n        if (consume(scanner, isImportant)) {\n            important = true;\n        }\n        else if (valueFragment = consumeValue(scanner, valueMode)) {\n            value.push(valueFragment);\n        }\n        else if (!consume(scanner, isFragmentDelimiter)) {\n            break;\n        }\n    }\n    if (name || value.length || important) {\n        return { name, value, important };\n    }\n}\n/**\n * Consumes single value fragment, e.g. all value tokens before comma\n */\nfunction consumeValue(scanner, inArgument) {\n    const result = [];\n    let token;\n    let args;\n    while (readable(scanner)) {\n        token = peek(scanner);\n        if (isValue(token)) {\n            scanner.pos++;\n            if (isLiteral$1(token) && (args = consumeArguments(scanner))) {\n                result.push({\n                    type: 'FunctionCall',\n                    name: token.value,\n                    arguments: args\n                });\n            }\n            else {\n                result.push(token);\n            }\n        }\n        else if (isValueDelimiter(token) || (inArgument && isWhiteSpace(token))) {\n            scanner.pos++;\n        }\n        else {\n            break;\n        }\n    }\n    return result.length\n        ? { type: 'CSSValue', value: result }\n        : void 0;\n}\nfunction consumeArguments(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isOpenBracket)) {\n        const args = [];\n        let value;\n        while (readable(scanner) && !consume(scanner, isCloseBracket)) {\n            if (value = consumeValue(scanner, true)) {\n                args.push(value);\n            }\n            else if (!consume(scanner, isWhiteSpace) && !consume(scanner, isArgumentDelimiter)) {\n                throw error(scanner, 'Unexpected token');\n            }\n        }\n        scanner.start = start;\n        return args;\n    }\n}\nfunction isLiteral$1(token) {\n    return token && token.type === 'Literal';\n}\nfunction isBracket$1(token, open) {\n    return token && token.type === 'Bracket' && (open == null || token.open === open);\n}\nfunction isOpenBracket(token) {\n    return isBracket$1(token, true);\n}\nfunction isCloseBracket(token) {\n    return isBracket$1(token, false);\n}\nfunction isWhiteSpace(token) {\n    return token && token.type === 'WhiteSpace';\n}\nfunction isOperator(token, operator) {\n    return token && token.type === 'Operator' && (!operator || token.operator === operator);\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, \"+\" /* Sibling */);\n}\nfunction isArgumentDelimiter(token) {\n    return isOperator(token, \",\" /* ArgumentDelimiter */);\n}\nfunction isFragmentDelimiter(token) {\n    return isArgumentDelimiter(token);\n}\nfunction isImportant(token) {\n    return isOperator(token, \"!\" /* Important */);\n}\nfunction isValue(token) {\n    return token.type === 'StringValue'\n        || token.type === 'ColorValue'\n        || token.type === 'NumberValue'\n        || token.type === 'Literal'\n        || token.type === 'Field';\n}\nfunction isValueDelimiter(token) {\n    return isOperator(token, \":\" /* PropertyDelimiter */)\n        || isOperator(token, \"-\" /* ValueDelimiter */);\n}\nfunction isFunctionStart(scanner) {\n    const t1 = scanner.tokens[scanner.pos];\n    const t2 = scanner.tokens[scanner.pos + 1];\n    return t1 && t2 && isLiteral$1(t1) && t2.type === 'Bracket';\n}\n\n/**\n * Parses given abbreviation into property set\n */\nfunction parse(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr, options && options.value) : abbr;\n        return parser(tokens, options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport default parse;\nexport { getToken, parser, tokenize };\n","import parse$2 from '@emmetio/abbreviation';\nexport { default as markupAbbreviation } from '@emmetio/abbreviation';\nimport parse$3 from '@emmetio/css-abbreviation';\nexport { default as stylesheetAbbreviation } from '@emmetio/css-abbreviation';\n\n/**\n * Merges attributes in current node: de-duplicates attributes with the same name\n * and merges class names\n */\nfunction mergeAttributes(node, config) {\n    if (!node.attributes) {\n        return;\n    }\n    const attributes = [];\n    const lookup = {};\n    for (const attr of node.attributes) {\n        if (attr.name) {\n            const attrName = attr.name;\n            if (attrName in lookup) {\n                const prev = lookup[attrName];\n                if (attrName === 'class') {\n                    prev.value = mergeValue(prev.value, attr.value, ' ');\n                }\n                else {\n                    mergeDeclarations(prev, attr, config);\n                }\n            }\n            else {\n                // Create new attribute instance so we can safely modify it later\n                attributes.push(lookup[attrName] = Object.assign({}, attr));\n            }\n        }\n        else {\n            attributes.push(attr);\n        }\n    }\n    node.attributes = attributes;\n}\n/**\n * Merges two token lists into single list. Adjacent strings are merged together\n */\nfunction mergeValue(prev, next, glue) {\n    if (prev && next) {\n        if (prev.length && glue) {\n            append(prev, glue);\n        }\n        for (const t of next) {\n            append(prev, t);\n        }\n        return prev;\n    }\n    const result = prev || next;\n    return result && result.slice();\n}\n/**\n * Merges data from `src` attribute into `dest` and returns it\n */\nfunction mergeDeclarations(dest, src, config) {\n    dest.name = src.name;\n    if (!config.options['output.reverseAttributes']) {\n        dest.value = src.value;\n    }\n    // Keep high-priority properties\n    if (!dest.implied) {\n        dest.implied = src.implied;\n    }\n    if (!dest.boolean) {\n        dest.boolean = src.boolean;\n    }\n    if (dest.valueType !== 'expression') {\n        dest.valueType = src.valueType;\n    }\n    return dest;\n}\nfunction append(tokens, value) {\n    const lastIx = tokens.length - 1;\n    if (typeof tokens[lastIx] === 'string' && typeof value === 'string') {\n        tokens[lastIx] += value;\n    }\n    else {\n        tokens.push(value);\n    }\n}\n\n/**\n * Walks over each child node of given markup abbreviation AST node (not including\n * given one) and invokes `fn` on each node.\n * The `fn` callback accepts context node, list of ancestor nodes and optional\n * state object\n */\nfunction walk(node, fn, state) {\n    const ancestors = [node];\n    const callback = (ctx) => {\n        fn(ctx, ancestors, state);\n        ancestors.push(ctx);\n        ctx.children.forEach(callback);\n        ancestors.pop();\n    };\n    node.children.forEach(callback);\n}\n/**\n * Finds node which is the deepest for in current node or node itself.\n */\nfunction findDeepest(node) {\n    let parent;\n    while (node.children.length) {\n        parent = node;\n        node = node.children[node.children.length - 1];\n    }\n    return { parent, node };\n}\nfunction isNode(node) {\n    return node.type === 'AbbreviationNode';\n}\n\n/**\n * Finds matching snippet from `registry` and resolves it into a parsed abbreviation.\n * Resolved node is then updated or replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attributes and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n */\nfunction resolveSnippets(abbr, config) {\n    const stack = [];\n    const reversed = config.options['output.reverseAttributes'];\n    const resolve = (child) => {\n        const snippet = child.name && config.snippets[child.name];\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.includes(snippet)) {\n            return null;\n        }\n        const snippetAbbr = parse$2(snippet, config);\n        stack.push(snippet);\n        walkResolve(snippetAbbr, resolve);\n        stack.pop();\n        // Add attributes from current node into every top-level node of parsed abbreviation\n        for (const topNode of snippetAbbr.children) {\n            if (child.attributes) {\n                const from = topNode.attributes || [];\n                const to = child.attributes || [];\n                topNode.attributes = reversed ? to.concat(from) : from.concat(to);\n            }\n            mergeNodes(child, topNode);\n        }\n        return snippetAbbr;\n    };\n    walkResolve(abbr, resolve);\n    return abbr;\n}\nfunction walkResolve(node, resolve, config) {\n    let children = [];\n    for (const child of node.children) {\n        const resolved = resolve(child);\n        if (resolved) {\n            children = children.concat(resolved.children);\n            const deepest = findDeepest(resolved);\n            if (isNode(deepest.node)) {\n                deepest.node.children = deepest.node.children.concat(walkResolve(child, resolve));\n            }\n        }\n        else {\n            children.push(child);\n            child.children = walkResolve(child, resolve);\n        }\n    }\n    return node.children = children;\n}\n/**\n * Adds data from first node into second node\n */\nfunction mergeNodes(from, to) {\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n    if (from.value != null) {\n        to.value = from.value;\n    }\n    if (from.repeat) {\n        to.repeat = from.repeat;\n    }\n}\n\nfunction createOutputStream(options, level = 0) {\n    return {\n        options,\n        value: '',\n        level,\n        offset: 0,\n        line: 0,\n        column: 0\n    };\n}\n/**\n * Pushes plain string into output stream without newline processing\n */\nfunction push(stream, text) {\n    const processText = stream.options['output.text'];\n    _push(stream, processText(text, stream.offset, stream.line, stream.column));\n}\n/**\n * Pushes given string with possible newline formatting into output\n */\nfunction pushString(stream, value) {\n    // If given value contains newlines, we should push content line-by-line and\n    // use `pushNewline()` to maintain proper line/column state\n    const lines = splitByLines(value);\n    for (let i = 0, il = lines.length - 1; i <= il; i++) {\n        push(stream, lines[i]);\n        if (i !== il) {\n            pushNewline(stream, true);\n        }\n    }\n}\n/**\n * Pushes new line into given output stream\n */\nfunction pushNewline(stream, indent) {\n    const baseIndent = stream.options['output.baseIndent'];\n    const newline = stream.options['output.newline'];\n    push(stream, newline + baseIndent);\n    stream.line++;\n    stream.column = baseIndent.length;\n    if (indent) {\n        pushIndent(stream, indent === true ? stream.level : indent);\n    }\n}\n/**\n * Adds indentation of `size` to current output stream\n */\nfunction pushIndent(stream, size = stream.level) {\n    const indent = stream.options['output.indent'];\n    push(stream, indent.repeat(Math.max(size, 0)));\n}\n/**\n * Pushes field/tabstop into output stream\n */\nfunction pushField(stream, index, placeholder) {\n    const field = stream.options['output.field'];\n    // NB: use `_push` instead of `push` to skip text processing\n    _push(stream, field(index, placeholder, stream.offset, stream.line, stream.column));\n}\n/**\n * Returns given tag name formatted according to given config\n */\nfunction tagName(name, config) {\n    return strCase(name, config.options['output.tagCase']);\n}\n/**\n * Returns given attribute name formatted according to given config\n */\nfunction attrName(name, config) {\n    return strCase(name, config.options['output.attributeCase']);\n}\n/**\n * Returns character for quoting value of given attribute\n */\nfunction attrQuote(attr, config, isOpen) {\n    if (attr.valueType === 'expression') {\n        return isOpen ? '{' : '}';\n    }\n    return config.options['output.attributeQuotes'] === 'single' ? '\\'' : '\"';\n}\n/**\n * Check if given attribute is boolean\n */\nfunction isBooleanAttribute(attr, config) {\n    return attr.boolean\n        || config.options['output.booleanAttributes'].includes((attr.name || '').toLowerCase());\n}\n/**\n * Returns a token for self-closing tag, depending on current options\n */\nfunction selfClose(config) {\n    switch (config.options['output.selfClosingStyle']) {\n        case 'xhtml': return ' /';\n        case 'xml': return '/';\n        default: return '';\n    }\n}\n/**\n * Check if given tag name belongs to inline-level element\n * @param node Parsed node or tag name\n */\nfunction isInline(node, config) {\n    if (typeof node === 'string') {\n        return config.options.inlineElements.includes(node.toLowerCase());\n    }\n    // inline node is a node either with inline-level name or text-only node\n    return node.name ? isInline(node.name, config) : Boolean(node.value && !node.attributes);\n}\n/**\n * Splits given text by lines\n */\nfunction splitByLines(text) {\n    return text.split(/\\r\\n|\\r|\\n/g);\n}\n/**\n * Pushes raw string into output stream without any processing\n */\nfunction _push(stream, text) {\n    stream.value += text;\n    stream.offset += text.length;\n    stream.column += text.length;\n}\nfunction strCase(str, type) {\n    if (type) {\n        return type === 'upper' ? str.toUpperCase() : str.toLowerCase();\n    }\n    return str;\n}\n\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\nfunction implicitTag(node, ancestors, config) {\n    if (!node.name && node.attributes) {\n        resolveImplicitTag(node, ancestors, config);\n    }\n}\nfunction resolveImplicitTag(node, ancestors, config) {\n    const parent = getParentElement(ancestors);\n    const contextName = config.context ? config.context.name : '';\n    const parentName = lowercase(parent ? parent.name : contextName);\n    node.name = elementMap[parentName]\n        || (isInline(parentName, config) ? 'span' : 'div');\n}\nfunction lowercase(str) {\n    return (str || '').toLowerCase();\n}\n/**\n * Returns closest element node from given ancestors list\n */\nfunction getParentElement(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const elem = ancestors[i];\n        if (isNode(elem)) {\n            return elem;\n        }\n    }\n}\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"далеко-далеко\", \"за\", \"словесными\", \"горами\", \"в стране\", \"гласных\", \"и согласных\", \"живут\", \"рыбные\", \"тексты\"],\n\t\"words\": [\"вдали\", \"от всех\", \"они\", \"буквенных\", \"домах\", \"на берегу\", \"семантика\",\n\t\t\"большого\", \"языкового\", \"океана\", \"маленький\", \"ручеек\", \"даль\",\n\t\t\"журчит\", \"по всей\", \"обеспечивает\", \"ее\",\"всеми\", \"необходимыми\",\n\t\t\"правилами\", \"эта\", \"парадигматическая\", \"страна\", \"которой\", \"жаренные\",\n\t\t\"предложения\", \"залетают\", \"прямо\", \"рот\", \"даже\", \"всемогущая\",\n\t\t\"пунктуация\", \"не\", \"имеет\", \"власти\", \"над\", \"рыбными\", \"текстами\",\n\t\t\"ведущими\", \"безорфографичный\", \"образ\", \"жизни\", \"однажды\", \"одна\",\n\t\t\"маленькая\", \"строчка\",\"рыбного\", \"текста\", \"имени\", \"lorem\", \"ipsum\",\n\t\t\"решила\", \"выйти\", \"большой\", \"мир\", \"грамматики\", \"великий\", \"оксмокс\",\n\t\t\"предупреждал\", \"о\", \"злых\", \"запятых\", \"диких\", \"знаках\", \"вопроса\",\n\t\t\"коварных\", \"точках\", \"запятой\", \"но\", \"текст\", \"дал\", \"сбить\",\n\t\t\"себя\", \"толку\", \"он\", \"собрал\", \"семь\", \"своих\", \"заглавных\", \"букв\",\n\t\t\"подпоясал\", \"инициал\", \"за\", \"пояс\", \"пустился\", \"дорогу\",\n\t\t\"взобравшись\", \"первую\", \"вершину\", \"курсивных\", \"гор\", \"бросил\",\n\t\t\"последний\", \"взгляд\", \"назад\", \"силуэт\", \"своего\", \"родного\", \"города\",\n\t\t\"буквоград\", \"заголовок\", \"деревни\", \"алфавит\", \"подзаголовок\", \"своего\",\n\t\t\"переулка\", \"грустный\", \"реторический\", \"вопрос\", \"скатился\", \"его\",\n\t\t\"щеке\", \"продолжил\", \"свой\", \"путь\", \"дороге\", \"встретил\", \"рукопись\",\n\t\t\"она\", \"предупредила\",  \"моей\", \"все\", \"переписывается\", \"несколько\",\n\t\t\"раз\", \"единственное\", \"что\", \"меня\", \"осталось\", \"это\", \"приставка\",\n\t\t\"возвращайся\", \"ты\", \"лучше\", \"свою\", \"безопасную\", \"страну\", \"послушавшись\",\n\t\t\"рукописи\", \"наш\", \"продолжил\", \"свой\", \"путь\", \"вскоре\", \"ему\",\n\t\t\"повстречался\", \"коварный\", \"составитель\", \"рекламных\", \"текстов\",\n\t\t\"напоивший\", \"языком\", \"речью\", \"заманивший\", \"свое\", \"агентство\",\n\t\t\"которое\", \"использовало\", \"снова\", \"снова\", \"своих\", \"проектах\",\n\t\t\"если\", \"переписали\", \"то\", \"живет\", \"там\", \"до\", \"сих\", \"пор\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"más\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"paño\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"demás\", \"oficinista\", \"excepción\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"cuórum\", \"dignísimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedición\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"león\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"séquito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asunción\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentación\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindío\", \"pócima\",\n\t\t\"voluble\", \"débito\", \"sintió\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mínima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaña\", \"enigma\",\n\t\t\"total\", \"deletéreo\", \"décima\", \"cábala\", \"fotografía\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnífico\", \"distinción\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepúsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abadía\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almácigo\", \"vos\", \"pan\",\n\t\t\"represión\", \"números\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrón\", \"explícito\",\n\t\t\"paloma\", \"síndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apéndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propósito\",\n\t\t\"fantasía\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst vocabularies = { ru, sp, latin };\nconst reLorem = /^lorem([a-z]*)(\\d*)(-\\d*)?$/i;\nfunction lorem(node, ancestors, config) {\n    let m;\n    if (node.name && (m = node.name.match(reLorem))) {\n        const db = vocabularies[m[1]] || vocabularies.latin;\n        const minWordCount = m[2] ? Math.max(1, Number(m[2])) : 30;\n        const maxWordCount = m[3] ? Math.max(minWordCount, Number(m[3].slice(1))) : minWordCount;\n        const wordCount = rand(minWordCount, maxWordCount);\n        const repeat = node.repeat || findRepeater(ancestors);\n        node.name = node.attributes = void 0;\n        node.value = [paragraph(db, wordCount, !repeat || repeat.value === 0)];\n        if (node.repeat && ancestors.length > 1) {\n            resolveImplicitTag(node, ancestors, config);\n        }\n    }\n}\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n */\nfunction rand(from, to) {\n    return Math.floor(Math.random() * (to - from) + from);\n}\nfunction sample(arr, count) {\n    const len = arr.length;\n    const iterations = Math.min(len, count);\n    const result = [];\n    while (result.length < iterations) {\n        const str = arr[rand(0, len)];\n        if (!result.includes(str)) {\n            result.push(str);\n        }\n    }\n    return result;\n}\nfunction choice(val) {\n    return val[rand(0, val.length - 1)];\n}\nfunction sentence(words, end) {\n    if (words.length) {\n        words = [capitalize(words[0])].concat(words.slice(1));\n    }\n    return words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\nfunction capitalize(word) {\n    return word[0].toUpperCase() + word.slice(1);\n}\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside `words` array\n */\nfunction insertCommas(words) {\n    if (words.length < 2) {\n        return words;\n    }\n    words = words.slice();\n    const len = words.length;\n    const hasComma = /,$/;\n    let totalCommas = 0;\n    if (len > 3 && len <= 6) {\n        totalCommas = rand(0, 1);\n    }\n    else if (len > 6 && len <= 12) {\n        totalCommas = rand(0, 2);\n    }\n    else {\n        totalCommas = rand(1, 4);\n    }\n    for (let i = 0, pos; i < totalCommas; i++) {\n        pos = rand(0, len - 2);\n        if (!hasComma.test(words[pos])) {\n            words[pos] += ',';\n        }\n    }\n    return words;\n}\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param dict Words dictionary\n * @param wordCount Words count in paragraph\n * @param startWithCommon Should paragraph start with common \"lorem ipsum\" sentence.\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n    const result = [];\n    let totalWords = 0;\n    let words;\n    if (startWithCommon && dict.common) {\n        words = dict.common.slice(0, wordCount);\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words), '.'));\n    }\n    while (totalWords < wordCount) {\n        words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words)));\n    }\n    return result.join(' ');\n}\nfunction findRepeater(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const element = ancestors[i];\n        if (element.type === 'AbbreviationNode' && element.repeat) {\n            return element.repeat;\n        }\n    }\n}\n\n/**\n * JSX transformer: replaces `class` and `for` attributes with `className` and\n * `htmlFor` attributes respectively\n */\nfunction jsx(node) {\n    if (node.attributes) {\n        node.attributes.forEach(rename);\n    }\n}\nfunction rename(attr) {\n    if (attr.name === 'class') {\n        attr.name = 'className';\n    }\n    else if (attr.name === 'for') {\n        attr.name = 'htmlFor';\n    }\n}\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nfunction xsl(node) {\n    if (matchesName(node.name) && node.attributes && (node.children.length || node.value)) {\n        node.attributes = node.attributes.filter(isAllowed);\n    }\n}\nfunction isAllowed(attr) {\n    return attr.name !== 'select';\n}\nfunction matchesName(name) {\n    return name === 'xsl:variable' || name === 'xsl:with-param';\n}\n\nconst reElement = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;\nconst blockCandidates1 = (className) => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = (className) => /^[a-z]/i.test(className);\nfunction bem(node, ancestors, config) {\n    expandClassNames(node);\n    expandShortNotation(node, ancestors, config);\n}\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n */\nfunction expandClassNames(node) {\n    const data = getBEMData(node);\n    const classNames = [];\n    for (const cl of data.classNames) {\n        // remove all modifiers and element prefixes from class name to get a base element name\n        const ix = cl.indexOf('_');\n        if (ix > 0 && !cl.startsWith('-')) {\n            classNames.push(cl.slice(0, ix));\n            classNames.push(cl.slice(ix));\n        }\n        else {\n            classNames.push(cl);\n        }\n    }\n    if (classNames.length) {\n        data.classNames = classNames.filter(uniqueClass);\n        data.block = findBlockName(data.classNames);\n        updateClass(node, data.classNames.join(' '));\n    }\n}\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n */\nfunction expandShortNotation(node, ancestors, config) {\n    const data = getBEMData(node);\n    const classNames = [];\n    const { options } = config;\n    const path = ancestors.slice(1).concat(node);\n    for (let cl of data.classNames) {\n        let prefix = '';\n        let m;\n        const originalClass = cl;\n        // parse element definition (could be only one)\n        if (m = cl.match(reElement)) {\n            prefix = getBlockName(path, m[1].length, config.context) + options['bem.element'] + m[2];\n            classNames.push(prefix);\n            cl = cl.slice(m[0].length);\n        }\n        // parse modifiers definitions\n        if (m = cl.match(reModifier)) {\n            if (!prefix) {\n                prefix = getBlockName(path, m[1].length);\n                classNames.push(prefix);\n            }\n            classNames.push(`${prefix}${options['bem.modifier']}${m[2]}`);\n            cl = cl.slice(m[0].length);\n        }\n        if (cl === originalClass) {\n            // class name wasn’t modified: it’s not a BEM-specific class,\n            // add it as-is into output\n            classNames.push(originalClass);\n        }\n    }\n    const arrClassNames = classNames.filter(uniqueClass);\n    if (arrClassNames.length) {\n        updateClass(node, arrClassNames.join(' '));\n    }\n}\n/**\n * Returns BEM data from given abbreviation node\n */\nfunction getBEMData(node) {\n    if (!node._bem) {\n        let classValue = '';\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (attr.name === 'class' && attr.value) {\n                    classValue = stringifyValue(attr.value);\n                    break;\n                }\n            }\n        }\n        node._bem = parseBEM(classValue);\n    }\n    return node._bem;\n}\nfunction getBEMDataFromContext(context) {\n    if (!context._bem) {\n        context._bem = parseBEM(context.attributes && context.attributes.class || '');\n    }\n    return context._bem;\n}\n/**\n * Parses BEM data from given class name\n */\nfunction parseBEM(classValue) {\n    const classNames = classValue ? classValue.split(/\\s+/) : [];\n    return {\n        classNames,\n        block: findBlockName(classNames)\n    };\n}\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n */\nfunction getBlockName(ancestors, depth = 0, context) {\n    const maxParentIx = 0;\n    let parentIx = Math.max(ancestors.length - depth, maxParentIx);\n    do {\n        const parent = ancestors[parentIx];\n        if (parent) {\n            const data = getBEMData(parent);\n            if (data.block) {\n                return data.block;\n            }\n        }\n    } while (maxParentIx < parentIx--);\n    if (context) {\n        const data = getBEMDataFromContext(context);\n        if (data.block) {\n            return data.block;\n        }\n    }\n    return '';\n}\nfunction findBlockName(classNames) {\n    return find(classNames, blockCandidates1)\n        || find(classNames, blockCandidates2)\n        || void 0;\n}\n/**\n * Finds class name from given list which may be used as block name\n */\nfunction find(classNames, filter) {\n    for (const cl of classNames) {\n        if (reElement.test(cl) || reModifier.test(cl)) {\n            break;\n        }\n        if (filter(cl)) {\n            return cl;\n        }\n    }\n}\nfunction updateClass(node, value) {\n    for (const attr of node.attributes) {\n        if (attr.name === 'class') {\n            attr.value = [value];\n            break;\n        }\n    }\n}\nfunction stringifyValue(value) {\n    let result = '';\n    for (const t of value) {\n        result += typeof t === 'string' ? t : t.name;\n    }\n    return result;\n}\nfunction uniqueClass(item, ix, arr) {\n    return !!item && arr.indexOf(item) === ix;\n}\n\nfunction walk$1(abbr, visitor, state) {\n    const callback = (ctx, index, items) => {\n        const { parent, current } = state;\n        state.parent = current;\n        state.current = ctx;\n        visitor(ctx, index, items, state, next);\n        state.current = current;\n        state.parent = parent;\n    };\n    const next = (node, index, items) => {\n        state.ancestors.push(state.current);\n        callback(node, index, items);\n        state.ancestors.pop();\n    };\n    abbr.children.forEach(callback);\n}\nfunction createWalkState(config) {\n    return {\n        // @ts-ignore: Will set value in iterator\n        current: null,\n        parent: void 0,\n        ancestors: [],\n        config,\n        field: 1,\n        out: createOutputStream(config.options)\n    };\n}\n\nconst caret = [{ type: 'Field', index: 0, name: '' }];\n/**\n * Check if given node is a snippet: a node without name and attributes\n */\nfunction isSnippet(node) {\n    return node ? !node.name && !node.attributes : false;\n}\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n */\nfunction isInlineElement(node, config) {\n    return node ? isInline(node, config) : false;\n}\n/**\n * Check if given value token is a field\n */\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field';\n}\nfunction pushTokens(tokens, state) {\n    const { out } = state;\n    let largestIndex = -1;\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            pushString(out, t);\n        }\n        else {\n            pushField(out, state.field + t.index, t.name);\n            if (t.index > largestIndex) {\n                largestIndex = t.index;\n            }\n        }\n    }\n    if (largestIndex !== -1) {\n        state.field += largestIndex + 1;\n    }\n}\n/**\n * Splits given value token by lines: returns array where each entry is a token list\n * for a single line\n */\nfunction splitByLines$1(tokens) {\n    const result = [];\n    let line = [];\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            const lines = t.split(/\\r\\n?|\\n/g);\n            line.push(lines.shift() || '');\n            while (lines.length) {\n                result.push(line);\n                line = [lines.shift() || ''];\n            }\n        }\n        else {\n            line.push(t);\n        }\n    }\n    line.length && result.push(line);\n    return result;\n}\n/**\n * Check if given attribute should be outputted\n */\nfunction shouldOutputAttribute(attr) {\n    // In case if attribute is implied, check if it has a defined value:\n    // either non-empty value or quoted empty value\n    return !attr.implied || attr.valueType !== 'raw' || (!!attr.value && attr.value.length > 0);\n}\n\n/**\n * Splits given string into template tokens.\n * Template is a string which contains placeholders which are uppercase names\n * between `[` and `]`, for example: `[PLACEHOLDER]`.\n * Unlike other templates, a placeholder may contain extra characters before and\n * after name: `[%PLACEHOLDER.]`. If data for `PLACEHOLDER` is defined, it will\n * be outputted with with these extra character, otherwise will be completely omitted.\n */\nfunction template(text) {\n    const tokens = [];\n    const scanner = { pos: 0, text };\n    let placeholder;\n    let offset = scanner.pos;\n    let pos = scanner.pos;\n    while (scanner.pos < scanner.text.length) {\n        pos = scanner.pos;\n        if (placeholder = consumePlaceholder(scanner)) {\n            if (offset !== scanner.pos) {\n                tokens.push(text.slice(offset, pos));\n            }\n            tokens.push(placeholder);\n            offset = scanner.pos;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n    if (offset !== scanner.pos) {\n        tokens.push(text.slice(offset));\n    }\n    return tokens;\n}\n/**\n * Consumes placeholder like `[#ID]` from given scanner\n */\nfunction consumePlaceholder(scanner) {\n    if (peek(scanner) === 91 /* Start */) {\n        const start = ++scanner.pos;\n        let namePos = start;\n        let afterPos = start;\n        let stack = 1;\n        while (scanner.pos < scanner.text.length) {\n            const code = peek(scanner);\n            if (isTokenStart(code)) {\n                namePos = scanner.pos;\n                while (isToken(peek(scanner))) {\n                    scanner.pos++;\n                }\n                afterPos = scanner.pos;\n            }\n            else {\n                if (code === 91 /* Start */) {\n                    stack++;\n                }\n                else if (code === 93 /* End */) {\n                    if (--stack === 0) {\n                        return {\n                            before: scanner.text.slice(start, namePos),\n                            after: scanner.text.slice(afterPos, scanner.pos++),\n                            name: scanner.text.slice(namePos, afterPos)\n                        };\n                    }\n                }\n                scanner.pos++;\n            }\n        }\n    }\n}\nfunction peek(scanner, pos = scanner.pos) {\n    return scanner.text.charCodeAt(pos);\n}\nfunction isTokenStart(code) {\n    return code >= 65 && code <= 90; // A-Z\n}\nfunction isToken(code) {\n    return isTokenStart(code)\n        || (code > 47 && code < 58) /* 0-9 */\n        || code === 95 /* Underscore */\n        || code === 45 /* Dash */;\n}\n\nfunction createCommentState(config) {\n    const { options } = config;\n    return {\n        enabled: options['comment.enabled'],\n        trigger: options['comment.trigger'],\n        before: options['comment.before'] ? template(options['comment.before']) : void 0,\n        after: options['comment.after'] ? template(options['comment.after']) : void 0\n    };\n}\n/**\n * Adds comment prefix for given node, if required\n */\nfunction commentNodeBefore(node, state) {\n    if (shouldComment(node, state) && state.comment.before) {\n        output(node, state.comment.before, state);\n    }\n}\n/**\n * Adds comment suffix for given node, if required\n */\nfunction commentNodeAfter(node, state) {\n    if (shouldComment(node, state) && state.comment.after) {\n        output(node, state.comment.after, state);\n    }\n}\n/**\n * Check if given node should be commented\n */\nfunction shouldComment(node, state) {\n    const { comment } = state;\n    if (!comment.enabled || !comment.trigger || !node.name || !node.attributes) {\n        return false;\n    }\n    for (const attr of node.attributes) {\n        if (attr.name && comment.trigger.includes(attr.name)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Pushes given template tokens into output stream\n */\nfunction output(node, tokens, state) {\n    const attrs = {};\n    const { out } = state;\n    // Collect attributes payload\n    for (const attr of node.attributes) {\n        if (attr.name && attr.value) {\n            attrs[attr.name.toUpperCase()] = attr.value;\n        }\n    }\n    // Output parsed tokens\n    for (const token of tokens) {\n        if (typeof token === 'string') {\n            pushString(out, token);\n        }\n        else if (attrs[token.name]) {\n            pushString(out, token.before);\n            pushTokens(attrs[token.name], state);\n            pushString(out, token.after);\n        }\n    }\n}\n\nconst htmlTagRegex = /^<([\\w\\-:]+)[\\s>]/;\nfunction html(abbr, config) {\n    const state = createWalkState(config);\n    state.comment = createCommentState(config);\n    walk$1(abbr, element, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element(node, index, items, state, next) {\n    const { out, config } = state;\n    const format = shouldFormat(node, index, items, state);\n    // Pick offset level for current node\n    const level = getIndent(state);\n    out.level += level;\n    format && pushNewline(out, true);\n    if (node.name) {\n        const name = tagName(node.name, config);\n        commentNodeBefore(node, state);\n        pushString(out, `<${name}`);\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (shouldOutputAttribute(attr)) {\n                    pushAttribute(attr, state);\n                }\n            }\n        }\n        if (node.selfClosing && !node.children.length && !node.value) {\n            pushString(out, `${selfClose(config)}>`);\n        }\n        else {\n            pushString(out, '>');\n            if (!pushSnippet(node, state, next)) {\n                if (node.value) {\n                    const innerFormat = node.value.some(hasNewline) || startsWithBlockTag(node.value, config);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(node.value, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n                node.children.forEach(next);\n                if (!node.value && !node.children.length) {\n                    const innerFormat = config.options['output.formatLeafNode']\n                        || config.options['output.formatForce'].includes(node.name);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(caret, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n            }\n            pushString(out, `</${name}>`);\n            commentNodeAfter(node, state);\n        }\n    }\n    else if (!pushSnippet(node, state, next) && node.value) {\n        // A text-only node (snippet)\n        pushTokens(node.value, state);\n        node.children.forEach(next);\n    }\n    if (format && index === items.length - 1 && state.parent) {\n        const offset = isSnippet(state.parent) ? 0 : 1;\n        pushNewline(out, out.level - offset);\n    }\n    out.level -= level;\n}\n/**\n * Outputs given attribute’s content into output stream\n */\nfunction pushAttribute(attr, state) {\n    const { out, config } = state;\n    if (attr.name) {\n        const name = attrName(attr.name, config);\n        const lQuote = attrQuote(attr, config, true);\n        const rQuote = attrQuote(attr, config);\n        let value = attr.value;\n        if (isBooleanAttribute(attr, config) && !value) {\n            // If attribute value is omitted and it’s a boolean value, check for\n            // `compactBoolean` option: if it’s disabled, set value to attribute name\n            // (XML style)\n            if (!config.options['output.compactBoolean']) {\n                value = [name];\n            }\n        }\n        else if (!value) {\n            value = caret;\n        }\n        pushString(out, ' ' + name);\n        if (value) {\n            pushString(out, '=' + lQuote);\n            pushTokens(value, state);\n            pushString(out, rQuote);\n        }\n        else if (config.options['output.selfClosingStyle'] !== 'html') {\n            pushString(out, '=' + lQuote + rQuote);\n        }\n    }\n}\nfunction pushSnippet(node, state, next) {\n    if (node.value && node.children.length) {\n        // We have a value and child nodes. In case if value contains fields,\n        // we should output children as a content of first field\n        const fieldIx = node.value.findIndex(isField);\n        if (fieldIx !== -1) {\n            pushTokens(node.value.slice(0, fieldIx), state);\n            const line = state.out.line;\n            let pos = fieldIx + 1;\n            node.children.forEach(next);\n            // If there was a line change, trim leading whitespace for better result\n            if (state.out.line !== line && typeof node.value[pos] === 'string') {\n                pushString(state.out, node.value[pos++].trimLeft());\n            }\n            pushTokens(node.value.slice(pos), state);\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Check if given node should be formatted in its parent context\n */\nfunction shouldFormat(node, index, items, state) {\n    const { config, parent } = state;\n    if (!config.options['output.format']) {\n        return false;\n    }\n    if (index === 0 && !parent) {\n        // Do not format very first node\n        return false;\n    }\n    // Do not format single child of snippet\n    if (parent && isSnippet(parent) && items.length === 1) {\n        return false;\n    }\n    /**\n     * Adjacent text-only/snippet nodes\n     */\n    if (isSnippet(node)) {\n        // Adjacent text-only/snippet nodes\n        const format = isSnippet(items[index - 1]) || isSnippet(items[index + 1])\n            // Has newlines: looks like wrapping code fragment\n            || node.value.some(hasNewline)\n            // Format as wrapper: contains children which will be outputted as field content\n            || (node.value.some(isField) && node.children.length);\n        if (format) {\n            return true;\n        }\n    }\n    if (isInline(node, config)) {\n        // Check if inline node is the next sibling of block-level node\n        if (index === 0) {\n            // First node in parent: format if it’s followed by a block-level element\n            for (let i = 0; i < items.length; i++) {\n                if (!isInline(items[i], config)) {\n                    return true;\n                }\n            }\n        }\n        else if (!isInline(items[index - 1], config)) {\n            // Node is right after block-level element\n            return true;\n        }\n        if (config.options['output.inlineBreak']) {\n            // check for adjacent inline elements before and after current element\n            let adjacentInline = 1;\n            let before = index;\n            let after = index;\n            while (isInlineElement(items[--before], config)) {\n                adjacentInline++;\n            }\n            while (isInlineElement(items[++after], config)) {\n                adjacentInline++;\n            }\n            if (adjacentInline >= config.options['output.inlineBreak']) {\n                return true;\n            }\n        }\n        // Edge case: inline node contains node that should receive formatting\n        for (let i = 0, il = node.children.length; i < il; i++) {\n            if (shouldFormat(node.children[i], i, node.children, state)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Returns indentation offset for given node\n */\nfunction getIndent(state) {\n    const { config, parent } = state;\n    if (!parent || isSnippet(parent) || (parent.name && config.options['output.formatSkip'].includes(parent.name))) {\n        return 0;\n    }\n    return 1;\n}\n/**\n * Check if given node value contains newlines\n */\nfunction hasNewline(value) {\n    return typeof value === 'string' && /\\r|\\n/.test(value);\n}\n/**\n * Check if given node value starts with block-level tag\n */\nfunction startsWithBlockTag(value, config) {\n    if (value.length && typeof value[0] === 'string') {\n        const matches = htmlTagRegex.exec(value[0]);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) && !config.options['inlineElements'].includes(matches[1].toLowerCase())) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction indentFormat(abbr, config, options) {\n    const state = createWalkState(config);\n    state.options = options || {};\n    walk$1(abbr, element$1, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element$1(node, index, items, state, next) {\n    const { out, options } = state;\n    const { primary, secondary } = collectAttributes(node);\n    // Pick offset level for current node\n    const level = state.parent ? 1 : 0;\n    out.level += level;\n    // Do not indent top-level elements\n    if (shouldFormat$1(node, index, items, state)) {\n        pushNewline(out, true);\n    }\n    if (node.name && (node.name !== 'div' || !primary.length)) {\n        pushString(out, (options.beforeName || '') + node.name + (options.afterName || ''));\n    }\n    pushPrimaryAttributes(primary, state);\n    pushSecondaryAttributes(secondary.filter(shouldOutputAttribute), state);\n    if (node.selfClosing && !node.value && !node.children.length) {\n        if (state.options.selfClose) {\n            pushString(out, state.options.selfClose);\n        }\n    }\n    else {\n        pushValue(node, state);\n        node.children.forEach(next);\n    }\n    out.level -= level;\n}\n/**\n * From given node, collects all attributes as `primary` (id, class) and\n * `secondary` (all the rest) lists. In most indent-based syntaxes, primary attribute\n * has special syntax\n */\nfunction collectAttributes(node) {\n    const primary = [];\n    const secondary = [];\n    if (node.attributes) {\n        for (const attr of node.attributes) {\n            if (isPrimaryAttribute(attr)) {\n                primary.push(attr);\n            }\n            else {\n                secondary.push(attr);\n            }\n        }\n    }\n    return { primary, secondary };\n}\n/**\n * Outputs given attributes as primary into output stream\n */\nfunction pushPrimaryAttributes(attrs, state) {\n    for (const attr of attrs) {\n        if (attr.value) {\n            if (attr.name === 'class') {\n                pushString(state.out, '.');\n                // All whitespace characters must be replaced with dots in class names\n                const tokens = attr.value.map(t => typeof t === 'string' ? t.replace(/\\s+/g, '.') : t);\n                pushTokens(tokens, state);\n            }\n            else {\n                // ID attribute\n                pushString(state.out, '#');\n                pushTokens(attr.value, state);\n            }\n        }\n    }\n}\n/**\n * Outputs given attributes as secondary into output stream\n */\nfunction pushSecondaryAttributes(attrs, state) {\n    if (attrs.length) {\n        const { out, config, options } = state;\n        options.beforeAttribute && pushString(out, options.beforeAttribute);\n        for (let i = 0; i < attrs.length; i++) {\n            const attr = attrs[i];\n            pushString(out, attrName(attr.name || '', config));\n            if (isBooleanAttribute(attr, config) && !attr.value) {\n                if (!config.options['output.compactBoolean'] && options.booleanValue) {\n                    pushString(out, '=' + options.booleanValue);\n                }\n            }\n            else {\n                pushString(out, '=' + attrQuote(attr, config, true));\n                pushTokens(attr.value || caret, state);\n                pushString(out, attrQuote(attr, config));\n            }\n            if (i !== attrs.length - 1 && options.glueAttribute) {\n                pushString(out, options.glueAttribute);\n            }\n        }\n        options.afterAttribute && pushString(out, options.afterAttribute);\n    }\n}\n/**\n * Outputs given node value into state output stream\n */\nfunction pushValue(node, state) {\n    // We should either output value or add caret but for leaf nodes only (no children)\n    if (!node.value && node.children.length) {\n        return;\n    }\n    const value = node.value || caret;\n    const lines = splitByLines$1(value);\n    const { out, options } = state;\n    if (lines.length === 1) {\n        if (node.name || node.attributes) {\n            push(out, ' ');\n        }\n        pushTokens(value, state);\n    }\n    else {\n        // We should format multi-line value with terminating `|` character\n        // and same line length\n        const lineLengths = [];\n        let maxLength = 0;\n        // Calculate lengths of all lines and max line length\n        for (const line of lines) {\n            const len = valueLength(line);\n            lineLengths.push(len);\n            if (len > maxLength) {\n                maxLength = len;\n            }\n        }\n        // Output each line, padded to max length\n        out.level++;\n        for (let i = 0; i < lines.length; i++) {\n            pushNewline(out, true);\n            options.beforeTextLine && push(out, options.beforeTextLine);\n            pushTokens(lines[i], state);\n            if (options.afterTextLine) {\n                push(out, ' '.repeat(maxLength - lineLengths[i]));\n                push(out, options.afterTextLine);\n            }\n        }\n        out.level--;\n    }\n}\nfunction isPrimaryAttribute(attr) {\n    return attr.name === 'class' || attr.name === 'id';\n}\n/**\n * Calculates string length from given tokens\n */\nfunction valueLength(tokens) {\n    let len = 0;\n    for (const token of tokens) {\n        len += typeof token === 'string' ? token.length : token.name.length;\n    }\n    return len;\n}\nfunction shouldFormat$1(node, index, items, state) {\n    // Do not format first top-level element or snippets\n    if (!state.parent && index === 0) {\n        return false;\n    }\n    return !isSnippet(node);\n}\n\nfunction haml(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeName: '%',\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ' ',\n        afterTextLine: ' |',\n        booleanValue: 'true',\n        selfClose: '/'\n    });\n}\n\nfunction slim(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: ' ',\n        glueAttribute: ' ',\n        beforeTextLine: '| ',\n        selfClose: '/'\n    });\n}\n\nfunction pug(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ', ',\n        beforeTextLine: '| ',\n        selfClose: config.options['output.selfClosingStyle'] === 'xml' ? '/' : ''\n    });\n}\n\nconst formatters = { html, haml, slim, pug };\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse(abbr, config) {\n    let oldTextValue;\n    if (typeof abbr === 'string') {\n        let parseOpt = config;\n        if (config.options['jsx.enabled']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { jsx: true });\n        }\n        if (config.options['markup.href']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { href: true });\n        }\n        abbr = parse$2(abbr, parseOpt);\n        // remove text field before snippets(abbr, config) call\n        // as abbreviation(abbr, parseOpt) already handled it\n        oldTextValue = config.text;\n        config.text = undefined;\n    }\n    // Run abbreviation resolve in two passes:\n    // 1. Map each node to snippets, which are abbreviations as well. A single snippet\n    // may produce multiple nodes\n    // 2. Transform every resolved node\n    abbr = resolveSnippets(abbr, config);\n    walk(abbr, transform, config);\n    config.text = oldTextValue !== null && oldTextValue !== void 0 ? oldTextValue : config.text;\n    return abbr;\n}\n/**\n * Converts given abbreviation to string according to provided `config`\n */\nfunction stringify(abbr, config) {\n    const formatter = formatters[config.syntax] || html;\n    return formatter(abbr, config);\n}\n/**\n * Modifies given node and prepares it for output\n */\nfunction transform(node, ancestors, config) {\n    implicitTag(node, ancestors, config);\n    mergeAttributes(node, config);\n    lorem(node, ancestors, config);\n    if (config.syntax === 'xsl') {\n        xsl(node);\n    }\n    if (config.options['jsx.enabled']) {\n        jsx(node);\n    }\n    if (config.options['bem.enabled']) {\n        bem(node, ancestors, config);\n    }\n}\n\nconst reProperty = /^([a-z-]+)(?:\\s*:\\s*([^\\n\\r;]+?);*)?$/;\nconst opt = { value: true };\n/**\n * Creates structure for holding resolved CSS snippet\n */\nfunction createSnippet(key, value) {\n    // A snippet could be a raw text snippet (e.g. arbitrary text string) or a\n    // CSS property with possible values separated by `|`.\n    // In latter case, we have to parse snippet as CSS abbreviation\n    const m = value.match(reProperty);\n    if (m) {\n        const keywords = {};\n        const parsed = m[2] ? m[2].split('|').map(parseValue) : [];\n        for (const item of parsed) {\n            for (const cssVal of item) {\n                collectKeywords(cssVal, keywords);\n            }\n        }\n        return {\n            type: \"Property\" /* Property */,\n            key,\n            property: m[1],\n            value: parsed,\n            keywords,\n            dependencies: []\n        };\n    }\n    return { type: \"Raw\" /* Raw */, key, value };\n}\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * `background-position-x` -> `background-position` -> `background`\n */\nfunction nest(snippets) {\n    snippets = snippets.slice().sort(snippetsSort);\n    const stack = [];\n    let prev;\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // background -> background-position -> background-position-x\n    for (const cur of snippets.filter(isProperty)) {\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n            if (cur.property.startsWith(prev.property)\n                && cur.property.charCodeAt(prev.property.length) === 45 /* - */) {\n                prev.dependencies.push(cur);\n                stack.push(cur);\n                break;\n            }\n            stack.pop();\n        }\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n    return snippets;\n}\n/**\n * A sorting function for array of snippets\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n    return a.key < b.key ? -1 : 1;\n}\nfunction parseValue(value) {\n    return parse$3(value.trim(), opt)[0].value;\n}\nfunction isProperty(snippet) {\n    return snippet.type === \"Property\" /* Property */;\n}\nfunction collectKeywords(cssVal, dest) {\n    for (const v of cssVal.value) {\n        if (v.type === 'Literal') {\n            dest[v.value] = v;\n        }\n        else if (v.type === 'FunctionCall') {\n            dest[v.name] = v;\n        }\n        else if (v.type === 'Field') {\n            // Create literal from field, if available\n            const value = v.name.trim();\n            if (value) {\n                dest[value] = { type: 'Literal', value };\n            }\n        }\n    }\n}\n\n/**\n * Calculates how close `str1` matches `str2` using fuzzy match.\n * How matching works:\n * – first characters of both `str1` and `str2` *must* match\n * – `str1` length larger than `str2` length is allowed only when `unmatched` is true\n * – ideal match is when `str1` equals to `str2` (score: 1)\n * – next best match is `str2` starts with `str1` (score: 1 × percent of matched characters)\n * – other scores depend on how close characters of `str1` to the beginning of `str2`\n * @param partialMatch Allow length `str1` to be greater than `str2` length\n */\nfunction scoreMatch(str1, str2, partialMatch = false) {\n    str1 = str1.toLowerCase();\n    str2 = str2.toLowerCase();\n    if (str1 === str2) {\n        return 1;\n    }\n    // Both strings MUST start with the same character\n    if (!str1 || !str2 || str1.charCodeAt(0) !== str2.charCodeAt(0)) {\n        return 0;\n    }\n    const str1Len = str1.length;\n    const str2Len = str2.length;\n    if (!partialMatch && str1Len > str2Len) {\n        return 0;\n    }\n    // Characters from `str1` which are closer to the beginning of a `str2` should\n    // have higher score.\n    // For example, if `str2` is `abcde`, it’s max score is:\n    // 5 + 4 + 3 + 2 + 1 = 15 (sum of character positions in reverse order)\n    // Matching `abd` against `abcde` should produce:\n    // 5 + 4 + 2 = 11\n    // Acronym bonus for match right after `-`. Matching `abd` against `abc-de`\n    // should produce:\n    // 6 + 5 + 4 (use `d` position in `abd`, not in abc-de`)\n    const minLength = Math.min(str1Len, str2Len);\n    const maxLength = Math.max(str1Len, str2Len);\n    let i = 1;\n    let j = 1;\n    let score = maxLength;\n    let ch1 = 0;\n    let ch2 = 0;\n    let found = false;\n    let acronym = false;\n    while (i < str1Len) {\n        ch1 = str1.charCodeAt(i);\n        found = false;\n        acronym = false;\n        while (j < str2Len) {\n            ch2 = str2.charCodeAt(j);\n            if (ch1 === ch2) {\n                found = true;\n                score += maxLength - (acronym ? i : j);\n                break;\n            }\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === 45 /* - */;\n            j++;\n        }\n        if (!found) {\n            if (!partialMatch) {\n                return 0;\n            }\n            break;\n        }\n        i++;\n    }\n    const matchRatio = i / maxLength;\n    const delta = maxLength - minLength;\n    const maxScore = sum(maxLength) - sum(delta);\n    return (score * matchRatio) / maxScore;\n}\n/**\n * Calculates sum of first `n` numbers, e.g. 1+2+3+...n\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nfunction color(token, shortHex) {\n    if (!token.r && !token.g && !token.b && !token.a) {\n        return 'transparent';\n    }\n    else if (token.a === 1) {\n        return asHex(token, shortHex);\n    }\n    return asRGB(token);\n}\n/**\n * Output given color as hex value\n * @param short Produce short value (e.g. #fff instead of #ffffff), if possible\n */\nfunction asHex(token, short) {\n    const fn = (short && isShortHex(token.r) && isShortHex(token.g) && isShortHex(token.b))\n        ? toShortHex : toHex;\n    return '#' + fn(token.r) + fn(token.g) + fn(token.b);\n}\n/**\n * Output current color as `rgba?(...)` CSS color\n */\nfunction asRGB(token) {\n    const values = [token.r, token.g, token.b];\n    if (token.a !== 1) {\n        values.push(frac(token.a, 8));\n    }\n    return `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n}\nfunction frac(num, digits = 4) {\n    return num.toFixed(digits).replace(/\\.?0+$/, '');\n}\nfunction isShortHex(hex) {\n    return !(hex % 17);\n}\nfunction toShortHex(num) {\n    return (num >> 4).toString(16);\n}\nfunction toHex(num) {\n    return pad(num.toString(16), 2);\n}\nfunction pad(value, len) {\n    while (value.length < len) {\n        value = '0' + value;\n    }\n    return value;\n}\n\nfunction css(abbr, config) {\n    var _a;\n    const out = createOutputStream(config.options);\n    const format = config.options['output.format'];\n    if (((_a = config.context) === null || _a === void 0 ? void 0 : _a.name) === \"@@section\" /* Section */) {\n        // For section context, filter out unmatched snippets\n        abbr = abbr.filter(node => node.snippet);\n    }\n    for (let i = 0; i < abbr.length; i++) {\n        if (format && i !== 0) {\n            pushNewline(out, true);\n        }\n        property(abbr[i], out, config);\n    }\n    return out.value;\n}\n/**\n * Outputs given abbreviation node into output stream\n */\nfunction property(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    if (node.name) {\n        // It’s a CSS property\n        const name = isJSON ? toCamelCase(node.name) : node.name;\n        pushString(out, name + config.options['stylesheet.between']);\n        if (node.value.length) {\n            propertyValue(node, out, config);\n        }\n        else {\n            pushField(out, 0, '');\n        }\n        if (isJSON) {\n            // For CSS-in-JS, always finalize property with comma\n            // NB: seems like `important` is not available in CSS-in-JS syntaxes\n            push(out, ',');\n        }\n        else {\n            outputImportant(node, out, true);\n            push(out, config.options['stylesheet.after']);\n        }\n    }\n    else {\n        // It’s a regular snippet, output plain tokens without any additional formatting\n        for (const cssVal of node.value) {\n            for (const v of cssVal.value) {\n                outputToken(v, out, config);\n            }\n        }\n        outputImportant(node, out, node.value.length > 0);\n    }\n}\nfunction propertyValue(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    const num = isJSON ? getSingleNumeric(node) : null;\n    if (num && (!num.unit || num.unit === 'px')) {\n        // For CSS-in-JS, if property contains single numeric value, output it\n        // as JS number\n        push(out, String(num.value));\n    }\n    else {\n        const quote = getQuote(config);\n        isJSON && push(out, quote);\n        for (let i = 0; i < node.value.length; i++) {\n            if (i !== 0) {\n                push(out, ', ');\n            }\n            outputValue(node.value[i], out, config);\n        }\n        isJSON && push(out, quote);\n    }\n}\nfunction outputImportant(node, out, separator) {\n    if (node.important) {\n        if (separator) {\n            push(out, ' ');\n        }\n        push(out, '!important');\n    }\n}\nfunction outputValue(value, out, config) {\n    for (let i = 0, prevEnd = -1; i < value.value.length; i++) {\n        const token = value.value[i];\n        // Handle edge case: a field is written close to previous token like this: `foo${bar}`.\n        // We should not add delimiter here\n        if (i !== 0 && (token.type !== 'Field' || token.start !== prevEnd)) {\n            push(out, ' ');\n        }\n        outputToken(token, out, config);\n        prevEnd = token['end'];\n    }\n}\nfunction outputToken(token, out, config) {\n    if (token.type === 'ColorValue') {\n        push(out, color(token, config.options['stylesheet.shortHex']));\n    }\n    else if (token.type === 'Literal') {\n        pushString(out, token.value);\n    }\n    else if (token.type === 'NumberValue') {\n        pushString(out, frac(token.value, 4) + token.unit);\n    }\n    else if (token.type === 'StringValue') {\n        const quote = token.quote === 'double' ? '\"' : '\\'';\n        pushString(out, quote + token.value + quote);\n    }\n    else if (token.type === 'Field') {\n        pushField(out, token.index, token.name);\n    }\n    else if (token.type === 'FunctionCall') {\n        push(out, token.name + '(');\n        for (let i = 0; i < token.arguments.length; i++) {\n            if (i) {\n                push(out, ', ');\n            }\n            outputValue(token.arguments[i], out, config);\n        }\n        push(out, ')');\n    }\n}\n/**\n * If value of given property is a single numeric value, returns this token\n */\nfunction getSingleNumeric(node) {\n    if (node.value.length === 1) {\n        const cssVal = node.value[0];\n        if (cssVal.value.length === 1 && cssVal.value[0].type === 'NumberValue') {\n            return cssVal.value[0];\n        }\n    }\n}\n/**\n * Converts kebab-case string to camelCase\n */\nfunction toCamelCase(str) {\n    return str.replace(/\\-(\\w)/g, (_, letter) => letter.toUpperCase());\n}\nfunction getQuote(config) {\n    return config.options['stylesheet.jsonDoubleQuotes'] ? '\"' : '\\'';\n}\n\nconst gradientName = 'lg';\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse$1(abbr, config) {\n    var _a;\n    const snippets = ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.stylesheetSnippets) || convertSnippets(config.snippets);\n    if (config.cache) {\n        config.cache.stylesheetSnippets = snippets;\n    }\n    if (typeof abbr === 'string') {\n        abbr = parse$3(abbr, { value: isValueScope(config) });\n    }\n    const filteredSnippets = getSnippetsForScope(snippets, config);\n    for (const node of abbr) {\n        resolveNode(node, filteredSnippets, config);\n    }\n    return abbr;\n}\n/**\n * Converts given raw snippets into internal snippets representation\n */\nfunction convertSnippets(snippets) {\n    const result = [];\n    for (const key of Object.keys(snippets)) {\n        result.push(createSnippet(key, snippets[key]));\n    }\n    return nest(result);\n}\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n */\nfunction resolveNode(node, snippets, config) {\n    if (!resolveGradient(node, config)) {\n        const score = config.options['stylesheet.fuzzySearchMinScore'];\n        if (isValueScope(config)) {\n            // Resolve as value of given CSS property\n            const propName = config.context.name;\n            const snippet = snippets.find(s => s.type === \"Property\" /* Property */ && s.property === propName);\n            resolveValueKeywords(node, config, snippet, score);\n            node.snippet = snippet;\n        }\n        else if (node.name) {\n            const snippet = findBestMatch(node.name, snippets, score, true);\n            node.snippet = snippet;\n            if (snippet) {\n                if (snippet.type === \"Property\" /* Property */) {\n                    resolveAsProperty(node, snippet, config);\n                }\n                else {\n                    resolveAsSnippet(node, snippet);\n                }\n            }\n        }\n    }\n    if (node.name || config.context) {\n        // Resolve numeric values for CSS properties only\n        resolveNumericValue(node, config);\n    }\n    return node;\n}\n/**\n * Resolves CSS gradient shortcut from given property, if possible\n */\nfunction resolveGradient(node, config) {\n    let gradientFn = null;\n    const cssVal = node.value.length === 1 ? node.value[0] : null;\n    if (cssVal && cssVal.value.length === 1) {\n        const v = cssVal.value[0];\n        if (v.type === 'FunctionCall' && v.name === gradientName) {\n            gradientFn = v;\n        }\n    }\n    if (gradientFn || node.name === gradientName) {\n        if (!gradientFn) {\n            gradientFn = {\n                type: 'FunctionCall',\n                name: 'linear-gradient',\n                arguments: [cssValue(field(0, ''))]\n            };\n        }\n        else {\n            gradientFn = Object.assign(Object.assign({}, gradientFn), { name: 'linear-gradient' });\n        }\n        if (!config.context) {\n            node.name = 'background-image';\n        }\n        node.value = [cssValue(gradientFn)];\n        return true;\n    }\n    return false;\n}\n/**\n * Resolves given parsed abbreviation node as CSS property\n */\nfunction resolveAsProperty(node, snippet, config) {\n    const abbr = node.name;\n    // Check for unmatched part of abbreviation\n    // For example, in `dib` abbreviation the matched part is `d` and `ib` should\n    // be considered as inline value. If unmatched fragment exists, we should check\n    // if it matches actual value of snippet. If either explicit value is specified\n    // or unmatched fragment did not resolve to to a keyword, we should consider\n    // matched snippet as invalid\n    const inlineValue = getUnmatchedPart(abbr, snippet.key);\n    if (inlineValue) {\n        if (node.value.length) {\n            // Already have value: unmatched part indicates matched snippet is invalid\n            return node;\n        }\n        const kw = resolveKeyword(inlineValue, config, snippet);\n        if (!kw) {\n            return node;\n        }\n        node.value.push(cssValue(kw));\n    }\n    node.name = snippet.property;\n    if (node.value.length) {\n        // Replace keyword alias from current abbreviation node with matched keyword\n        resolveValueKeywords(node, config, snippet);\n    }\n    else if (snippet.value.length) {\n        const defaultValue = snippet.value[0];\n        // https://github.com/emmetio/emmet/issues/558\n        // We should auto-select inserted value only if there’s multiple value\n        // choice\n        node.value = snippet.value.length === 1 || defaultValue.some(hasField)\n            ? defaultValue\n            : defaultValue.map(n => wrapWithField(n, config));\n    }\n    return node;\n}\nfunction resolveValueKeywords(node, config, snippet, minScore) {\n    for (const cssVal of node.value) {\n        const value = [];\n        for (const token of cssVal.value) {\n            if (token.type === 'Literal') {\n                value.push(resolveKeyword(token.value, config, snippet, minScore) || token);\n            }\n            else if (token.type === 'FunctionCall') {\n                // For function calls, we should find matching function call\n                // and merge arguments\n                const match = resolveKeyword(token.name, config, snippet, minScore);\n                if (match && match.type === 'FunctionCall') {\n                    value.push(Object.assign(Object.assign({}, match), { arguments: token.arguments.concat(match.arguments.slice(token.arguments.length)) }));\n                }\n                else {\n                    value.push(token);\n                }\n            }\n            else {\n                value.push(token);\n            }\n        }\n        cssVal.value = value;\n    }\n}\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n */\nfunction resolveAsSnippet(node, snippet) {\n    // When resolving snippets, we have to do the following:\n    // 1. Replace field placeholders with actual field tokens.\n    // 2. If input values given, put them instead of fields\n    let offset = 0;\n    let m;\n    const reField = /\\$\\{(\\d+)(:[^}]+)?\\}/g;\n    const inputValue = node.value[0];\n    const outputValue = [];\n    while (m = reField.exec(snippet.value)) {\n        if (offset !== m.index) {\n            outputValue.push(literal(snippet.value.slice(offset, m.index)));\n        }\n        offset = m.index + m[0].length;\n        if (inputValue && inputValue.value.length) {\n            outputValue.push(inputValue.value.shift());\n        }\n        else {\n            outputValue.push(field(Number(m[1]), m[2] ? m[2].slice(1) : ''));\n        }\n    }\n    const tail = snippet.value.slice(offset);\n    if (tail) {\n        outputValue.push(literal(tail));\n    }\n    node.name = void 0;\n    node.value = [cssValue(...outputValue)];\n    return node;\n}\n/**\n * Finds best matching item from `items` array\n * @param abbr  Abbreviation to match\n * @param items List of items for match\n * @param minScore The minimum score the best matched item should have to be a valid match.\n */\nfunction findBestMatch(abbr, items, minScore = 0, partialMatch = false) {\n    let matchedItem = null;\n    let maxScore = 0;\n    for (const item of items) {\n        const score = scoreMatch(abbr, getScoringPart(item), partialMatch);\n        if (score === 1) {\n            // direct hit, no need to look further\n            return item;\n        }\n        if (score && score >= maxScore) {\n            maxScore = score;\n            matchedItem = item;\n        }\n    }\n    return maxScore >= minScore ? matchedItem : null;\n}\nfunction getScoringPart(item) {\n    return typeof item === 'string' ? item : item.key;\n}\n/**\n * Returns a part of `abbr` that wasn’t directly matched against `str`.\n * For example, if abbreviation `poas` is matched against `position`,\n * the unmatched part will be `as` since `a` wasn’t found in string stream\n */\nfunction getUnmatchedPart(abbr, str) {\n    for (let i = 0, lastPos = 0; i < abbr.length; i++) {\n        lastPos = str.indexOf(abbr[i], lastPos);\n        if (lastPos === -1) {\n            return abbr.slice(i);\n        }\n        lastPos++;\n    }\n    return '';\n}\n/**\n * Resolves given keyword shorthand into matched snippet keyword or global keyword,\n * if possible\n */\nfunction resolveKeyword(kw, config, snippet, minScore) {\n    let ref;\n    if (snippet) {\n        if (ref = findBestMatch(kw, Object.keys(snippet.keywords), minScore)) {\n            return snippet.keywords[ref];\n        }\n        for (const dep of snippet.dependencies) {\n            if (ref = findBestMatch(kw, Object.keys(dep.keywords), minScore)) {\n                return dep.keywords[ref];\n            }\n        }\n    }\n    if (ref = findBestMatch(kw, config.options['stylesheet.keywords'], minScore)) {\n        return literal(ref);\n    }\n    return null;\n}\n/**\n * Resolves numeric values in given abbreviation node\n */\nfunction resolveNumericValue(node, config) {\n    const aliases = config.options['stylesheet.unitAliases'];\n    const unitless = config.options['stylesheet.unitless'];\n    for (const v of node.value) {\n        for (const t of v.value) {\n            if (t.type === 'NumberValue') {\n                if (t.unit) {\n                    t.unit = aliases[t.unit] || t.unit;\n                }\n                else if (t.value !== 0 && !unitless.includes(node.name)) {\n                    t.unit = t.rawValue.includes('.')\n                        ? config.options['stylesheet.floatUnit']\n                        : config.options['stylesheet.intUnit'];\n                }\n            }\n        }\n    }\n}\n/**\n * Constructs CSS value token\n */\nfunction cssValue(...args) {\n    return {\n        type: 'CSSValue',\n        value: args\n    };\n}\n/**\n * Constructs literal token\n */\nfunction literal(value) {\n    return { type: 'Literal', value };\n}\n/**\n * Constructs field token\n */\nfunction field(index, name) {\n    return { type: 'Field', index, name };\n}\n/**\n * Check if given value contains fields\n */\nfunction hasField(value) {\n    for (const v of value.value) {\n        if (v.type === 'Field' || (v.type === 'FunctionCall' && v.arguments.some(hasField))) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Wraps tokens of given abbreviation with fields\n */\nfunction wrapWithField(node, config, state = { index: 1 }) {\n    let value = [];\n    for (const v of node.value) {\n        switch (v.type) {\n            case 'ColorValue':\n                value.push(field(state.index++, color(v, config.options['stylesheet.shortHex'])));\n                break;\n            case 'Literal':\n                value.push(field(state.index++, v.value));\n                break;\n            case 'NumberValue':\n                value.push(field(state.index++, `${v.value}${v.unit}`));\n                break;\n            case 'StringValue':\n                const q = v.quote === 'single' ? '\\'' : '\"';\n                value.push(field(state.index++, q + v.value + q));\n                break;\n            case 'FunctionCall':\n                value.push(field(state.index++, v.name), literal('('));\n                for (let i = 0, il = v.arguments.length; i < il; i++) {\n                    value = value.concat(wrapWithField(v.arguments[i], config, state).value);\n                    if (i !== il - 1) {\n                        value.push(literal(', '));\n                    }\n                }\n                value.push(literal(')'));\n                break;\n            default:\n                value.push(v);\n        }\n    }\n    return Object.assign(Object.assign({}, node), { value });\n}\n/**\n * Check if abbreviation should be expanded in CSS value context\n */\nfunction isValueScope(config) {\n    if (config.context) {\n        return config.context.name === \"@@value\" /* Value */ || !config.context.name.startsWith('@@');\n    }\n    return false;\n}\n/**\n * Returns snippets for given scope\n */\nfunction getSnippetsForScope(snippets, config) {\n    if (config.context) {\n        if (config.context.name === \"@@section\" /* Section */) {\n            return snippets.filter(s => s.type === \"Raw\" /* Raw */);\n        }\n        if (config.context.name === \"@@property\" /* Property */) {\n            return snippets.filter(s => s.type === \"Property\" /* Property */);\n        }\n    }\n    return snippets;\n}\n\nvar markupSnippets = {\n\t\"a\": \"a[href]\",\n\t\"a:blank\": \"a[href='http://${0}' target='_blank' rel='noopener noreferrer']\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:mf|link:manifest\": \"link[rel='manifest' href='${1:manifest.json}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"meta:kw\": \"meta[name=keywords content]\",\n\t\"meta:desc\": \"meta[name=description content]\",\n\t\"style\": \"style\",\n\t\"script\": \"script\",\n\t\"script:src\": \"script[src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:btn|input:button\": \"input[type=button value]\",\n\t\"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"sum\": \"summary\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta[http-equiv='X-UA-Compatible'][content='IE=edge']+meta:vp+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar stylesheetSnippets = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${2});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly\",\n\t\"ai\": \"align-items:start|end|flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:time\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:${1:#000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:${1:#000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:${1:#000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:${1:#000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:${1:#000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:${1:#000}\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:#${1:fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:${1:#000}\",\n\t\"cr\": \"color:rgb(${1:0}, ${2:0}, ${3:0})\",\n\t\"cra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, ${4:.5})\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters(${0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|grid|inline-grid|subgrid|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fd\": \"font-display:auto|block|swap|fallback|optional\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fft\": \"font-family:\\\"Times New Roman\\\", Times, Baskerville, Georgia, serif\",\n\t\"ffa\": \"font-family:Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif\",\n\t\"ffv\": \"font-family:Verdana, Geneva, sans-serif\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fvs\": \"font-variation-settings:normal|inherit|initial|unset\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fsz\": \"font-size\",\n\t\"fsza\": \"font-size-adjust\",\n\t\"gtc\": \"grid-template-columns:repeat(${0})|minmax()\",\n\t\"gtr\": \"grid-template-rows:repeat(${0})|minmax()\",\n\t\"gta\": \"grid-template-areas\",\n\t\"gt\": \"grid-template\",\n\t\"gg\": \"grid-gap\",\n\t\"gcg\": \"grid-column-gap\",\n\t\"grg\": \"grid-row-gap\",\n\t\"gac\": \"grid-auto-columns:auto|minmax()\",\n\t\"gar\": \"grid-auto-rows:auto|minmax()\",\n\t\"gaf\": \"grid-auto-flow:row|column|dense|inherit|initial|unset\",\n\t\"gd\": \"grid\",\n\t\"gc\": \"grid-column\",\n\t\"gcs\": \"grid-column-start\",\n\t\"gce\": \"grid-column-end\",\n\t\"gr\": \"grid-row\",\n\t\"grs\": \"grid-row-start\",\n\t\"gre\": \"grid-row-end\",\n\t\"ga\": \"grid-area\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly\",\n\t\"ji\": \"justify-items:start|end|center|stretch\",\n\t\"js\": \"justify-self:start|end|center|stretch\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:${1:#000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op|opa\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar xslSnippets = {\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n};\n\nvar pugSnippets = {\n\t\"!!!\": \"{doctype html}\"\n};\n\nvar variables = {\n\t\"lang\": \"en\",\n\t\"locale\": \"en-US\",\n\t\"charset\": \"UTF-8\",\n\t\"indentation\": \"\\t\",\n\t\"newline\": \"\\n\"\n};\n\n/**\n * Default syntaxes for abbreviation types\n */\nconst defaultSyntaxes = {\n    markup: 'html',\n    stylesheet: 'css'\n};\nconst defaultOptions = {\n    'inlineElements': [\n        'a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n        'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n        'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n        's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n        'textarea', 'tt', 'u', 'var'\n    ],\n    'output.indent': '\\t',\n    'output.baseIndent': '',\n    'output.newline': '\\n',\n    'output.tagCase': '',\n    'output.attributeCase': '',\n    'output.attributeQuotes': 'double',\n    'output.format': true,\n    'output.formatLeafNode': false,\n    'output.formatSkip': ['html'],\n    'output.formatForce': ['body'],\n    'output.inlineBreak': 3,\n    'output.compactBoolean': false,\n    'output.booleanAttributes': [\n        'contenteditable', 'seamless', 'async', 'autofocus',\n        'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n        'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n        'required', 'reversed', 'selected', 'typemustmatch'\n    ],\n    'output.reverseAttributes': false,\n    'output.selfClosingStyle': 'html',\n    'output.field': (index, placeholder) => placeholder,\n    'output.text': text => text,\n    'markup.href': true,\n    'comment.enabled': false,\n    'comment.trigger': ['id', 'class'],\n    'comment.before': '',\n    'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n    'bem.enabled': false,\n    'bem.element': '__',\n    'bem.modifier': '_',\n    'jsx.enabled': false,\n    'stylesheet.keywords': ['auto', 'inherit', 'unset', 'none'],\n    'stylesheet.unitless': ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'],\n    'stylesheet.shortHex': true,\n    'stylesheet.between': ': ',\n    'stylesheet.after': ';',\n    'stylesheet.intUnit': 'px',\n    'stylesheet.floatUnit': 'em',\n    'stylesheet.unitAliases': { e: 'em', p: '%', x: 'ex', r: 'rem' },\n    'stylesheet.json': false,\n    'stylesheet.jsonDoubleQuotes': false,\n    'stylesheet.fuzzySearchMinScore': 0\n};\nconst defaultConfig = {\n    type: 'markup',\n    syntax: 'html',\n    variables,\n    snippets: {},\n    options: defaultOptions\n};\n/**\n * Default per-syntax config\n */\nconst syntaxConfig = {\n    markup: {\n        snippets: parseSnippets(markupSnippets),\n    },\n    xhtml: {\n        options: {\n            'output.selfClosingStyle': 'xhtml'\n        }\n    },\n    xml: {\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    xsl: {\n        snippets: parseSnippets(xslSnippets),\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    jsx: {\n        options: {\n            'jsx.enabled': true\n        }\n    },\n    pug: {\n        snippets: parseSnippets(pugSnippets)\n    },\n    stylesheet: {\n        snippets: parseSnippets(stylesheetSnippets)\n    },\n    sass: {\n        options: {\n            'stylesheet.after': ''\n        }\n    },\n    stylus: {\n        options: {\n            'stylesheet.between': ' ',\n            'stylesheet.after': '',\n        }\n    }\n};\n/**\n * Parses raw snippets definitions with possibly multiple keys into a plan\n * snippet map\n */\nfunction parseSnippets(snippets) {\n    const result = {};\n    Object.keys(snippets).forEach(k => {\n        for (const name of k.split('|')) {\n            result[name] = snippets[k];\n        }\n    });\n    return result;\n}\nfunction resolveConfig(config = {}, globals = {}) {\n    const type = config.type || 'markup';\n    const syntax = config.syntax || defaultSyntaxes[type];\n    return Object.assign(Object.assign(Object.assign({}, defaultConfig), config), { type,\n        syntax, variables: mergedData(type, syntax, 'variables', config, globals), snippets: mergedData(type, syntax, 'snippets', config, globals), options: mergedData(type, syntax, 'options', config, globals) });\n}\nfunction mergedData(type, syntax, key, config, globals = {}) {\n    const typeDefaults = syntaxConfig[type];\n    const typeOverride = globals[type];\n    const syntaxDefaults = syntaxConfig[syntax];\n    const syntaxOverride = globals[syntax];\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaultConfig[key]), (typeDefaults && typeDefaults[key])), (syntaxDefaults && syntaxDefaults[key])), (typeOverride && typeOverride[key])), (syntaxOverride && syntaxOverride[key])), config[key]);\n}\n\n/**\n * Creates structure for scanning given string in backward direction\n */\nfunction backwardScanner(text, start = 0) {\n    return { text, start, pos: text.length };\n}\n/**\n * Check if given scanner position is at start of scanned text\n */\nfunction sol(scanner) {\n    return scanner.pos === scanner.start;\n}\n/**\n * “Peeks” character code an current scanner location without advancing it\n */\nfunction peek$1(scanner, offset = 0) {\n    return scanner.text.charCodeAt(scanner.pos - 1 + offset);\n}\n/**\n * Returns current character code and moves character location one symbol back\n */\nfunction previous(scanner) {\n    if (!sol(scanner)) {\n        return scanner.text.charCodeAt(--scanner.pos);\n    }\n}\n/**\n * Consumes current character code if it matches given `match` code or function\n */\nfunction consume(scanner, match) {\n    if (sol(scanner)) {\n        return false;\n    }\n    const ok = typeof match === 'function'\n        ? match(peek$1(scanner))\n        : match === peek$1(scanner);\n    if (ok) {\n        scanner.pos--;\n    }\n    return !!ok;\n}\nfunction consumeWhile(scanner, match) {\n    const start = scanner.pos;\n    while (consume(scanner, match)) {\n        // empty\n    }\n    return scanner.pos < start;\n}\n\n/**\n * Check if given character code is a quote\n */\nfunction isQuote(c) {\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\n/**\n * Consumes quoted value, if possible\n * @return Returns `true` is value was consumed\n */\nfunction consumeQuoted(scanner) {\n    const start = scanner.pos;\n    const quote = previous(scanner);\n    if (isQuote(quote)) {\n        while (!sol(scanner)) {\n            if (previous(scanner) === quote && peek$1(scanner) !== 92 /* Escape */) {\n                return true;\n            }\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n\nconst bracePairs = {\n    [91 /* SquareL */]: 93 /* SquareR */,\n    [40 /* RoundL */]: 41 /* RoundR */,\n    [123 /* CurlyL */]: 125 /* CurlyR */,\n};\n\n/**\n * Check if given reader’s current position points at the end of HTML tag\n */\nfunction isHtml(scanner) {\n    const start = scanner.pos;\n    if (!consume(scanner, 62 /* AngleRight */)) {\n        return false;\n    }\n    let ok = false;\n    consume(scanner, 47 /* Slash */); // possibly self-closed element\n    while (!sol(scanner)) {\n        consumeWhile(scanner, isWhiteSpace);\n        if (consumeIdent(scanner)) {\n            // ate identifier: could be a tag name, boolean attribute or unquoted\n            // attribute value\n            if (consume(scanner, 47 /* Slash */)) {\n                // either closing tag or invalid tag\n                ok = consume(scanner, 60 /* AngleLeft */);\n                break;\n            }\n            else if (consume(scanner, 60 /* AngleLeft */)) {\n                // opening tag\n                ok = true;\n                break;\n            }\n            else if (consume(scanner, isWhiteSpace)) {\n                // boolean attribute\n                continue;\n            }\n            else if (consume(scanner, 61 /* Equals */)) {\n                // simple unquoted value or invalid attribute\n                if (consumeIdent(scanner)) {\n                    continue;\n                }\n                break;\n            }\n            else if (consumeAttributeWithUnquotedValue(scanner)) {\n                // identifier was a part of unquoted value\n                ok = true;\n                break;\n            }\n            // invalid tag\n            break;\n        }\n        if (consumeAttribute(scanner)) {\n            continue;\n        }\n        break;\n    }\n    scanner.pos = start;\n    return ok;\n}\n/**\n * Consumes HTML attribute from given string.\n * @return `true` if attribute was consumed.\n */\nfunction consumeAttribute(scanner) {\n    return consumeAttributeWithQuotedValue(scanner) || consumeAttributeWithUnquotedValue(scanner);\n}\nfunction consumeAttributeWithQuotedValue(scanner) {\n    const start = scanner.pos;\n    if (consumeQuoted(scanner) && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\nfunction consumeAttributeWithUnquotedValue(scanner) {\n    const start = scanner.pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        const ch = peek$1(scanner);\n        if (isCloseBracket(ch)) {\n            stack.push(ch);\n        }\n        else if (isOpenBracket(ch)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // Unexpected open bracket\n                break;\n            }\n        }\n        else if (!isUnquotedValue(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (start !== scanner.pos && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes HTML identifier from stream\n */\nfunction consumeIdent(scanner) {\n    return consumeWhile(scanner, isIdent);\n}\n/**\n * Check if given character code belongs to HTML identifier\n */\nfunction isIdent(ch) {\n    return ch === 58 /* Colon */ || ch === 45 /* Dash */ || isAlpha(ch) || isNumber(ch);\n}\n/**\n * Check if given character code is alpha code (letter though A to Z)\n */\nfunction isAlpha(ch) {\n    ch &= ~32; // quick hack to convert any char code to uppercase char code\n    return ch >= 65 && ch <= 90; // A-Z\n}\n/**\n * Check if given code is a number\n */\nfunction isNumber(ch) {\n    return ch > 47 && ch < 58;\n}\n/**\n * Check if given code is a whitespace\n */\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* Space */ || ch === 9 /* Tab */;\n}\n/**\n * Check if given code may belong to unquoted attribute value\n */\nfunction isUnquotedValue(ch) {\n    return !isNaN(ch) && ch !== 61 /* Equals */ && !isWhiteSpace(ch) && !isQuote(ch);\n}\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyL */ || ch === 40 /* RoundL */ || ch === 91 /* SquareL */;\n}\nfunction isCloseBracket(ch) {\n    return ch === 125 /* CurlyR */ || ch === 41 /* RoundR */ || ch === 93 /* SquareR */;\n}\n\nconst code = (ch) => ch.charCodeAt(0);\nconst specialChars = '#.*:$-_!@%^+>/'.split('').map(code);\nconst defaultOptions$1 = {\n    type: 'markup',\n    lookAhead: true,\n    prefix: ''\n};\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editor’s line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param line A text line where abbreviation should be expanded\n * @param pos Caret position in line. If not given, uses end of line\n * @param options Extracting options\n */\nfunction extractAbbreviation(line, pos = line.length, options = {}) {\n    // make sure `pos` is within line range\n    const opt = Object.assign(Object.assign({}, defaultOptions$1), options);\n    pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n    if (opt.lookAhead) {\n        pos = offsetPastAutoClosed(line, pos, opt);\n    }\n    let ch;\n    const start = getStartOffset(line, pos, opt.prefix || '');\n    if (start === -1) {\n        return void 0;\n    }\n    const scanner = backwardScanner(line, start);\n    scanner.pos = pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        ch = peek$1(scanner);\n        if (stack.includes(125 /* CurlyR */)) {\n            if (ch === 125 /* CurlyR */) {\n                stack.push(ch);\n                scanner.pos--;\n                continue;\n            }\n            if (ch !== 123 /* CurlyL */) {\n                scanner.pos--;\n                continue;\n            }\n        }\n        if (isCloseBrace(ch, opt.type)) {\n            stack.push(ch);\n        }\n        else if (isOpenBrace(ch, opt.type)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // unexpected brace\n                break;\n            }\n        }\n        else if (stack.includes(93 /* SquareR */) || stack.includes(125 /* CurlyR */)) {\n            // respect all characters inside attribute sets or text nodes\n            scanner.pos--;\n            continue;\n        }\n        else if (isHtml(scanner) || !isAbbreviation(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (!stack.length && scanner.pos !== pos) {\n        // Found something, remove some invalid symbols from the\n        // beginning and return abbreviation\n        const abbreviation = line.slice(scanner.pos, pos).replace(/^[*+>^]+/, '');\n        return {\n            abbreviation,\n            location: pos - abbreviation.length,\n            start: options.prefix\n                ? start - options.prefix.length\n                : pos - abbreviation.length,\n            end: pos\n        };\n    }\n}\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * editor will likely automatically close, e.g. }, ], and quotes\n */\nfunction offsetPastAutoClosed(line, pos, options) {\n    // closing quote is allowed only as a next character\n    if (isQuote(line.charCodeAt(pos))) {\n        pos++;\n    }\n    // offset pointer until non-autoclosed character is found\n    while (isCloseBrace(line.charCodeAt(pos), options.type)) {\n        pos++;\n    }\n    return pos;\n}\n/**\n * Returns start offset (left limit) in `line` where we should stop looking for\n * abbreviation: it’s nearest to `pos` location of `prefix` token\n */\nfunction getStartOffset(line, pos, prefix) {\n    if (!prefix) {\n        return 0;\n    }\n    const scanner = backwardScanner(line);\n    const compiledPrefix = prefix.split('').map(code);\n    scanner.pos = pos;\n    let result;\n    while (!sol(scanner)) {\n        if (consumePair(scanner, 93 /* SquareR */, 91 /* SquareL */) || consumePair(scanner, 125 /* CurlyR */, 123 /* CurlyL */)) {\n            continue;\n        }\n        result = scanner.pos;\n        if (consumeArray(scanner, compiledPrefix)) {\n            return result;\n        }\n        scanner.pos--;\n    }\n    return -1;\n}\n/**\n * Consumes full character pair, if possible\n */\nfunction consumePair(scanner, close, open) {\n    const start = scanner.pos;\n    if (consume(scanner, close)) {\n        while (!sol(scanner)) {\n            if (consume(scanner, open)) {\n                return true;\n            }\n            scanner.pos--;\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes all character codes from given array, right-to-left, if possible\n */\nfunction consumeArray(scanner, arr) {\n    const start = scanner.pos;\n    let consumed = false;\n    for (let i = arr.length - 1; i >= 0 && !sol(scanner); i--) {\n        if (!consume(scanner, arr[i])) {\n            break;\n        }\n        consumed = i === 0;\n    }\n    if (!consumed) {\n        scanner.pos = start;\n    }\n    return consumed;\n}\nfunction isAbbreviation(ch) {\n    return (ch > 64 && ch < 91) // uppercase letter\n        || (ch > 96 && ch < 123) // lowercase letter\n        || (ch > 47 && ch < 58) // number\n        || specialChars.includes(ch); // special character\n}\nfunction isOpenBrace(ch, syntax) {\n    return ch === 40 /* RoundL */ || (syntax === 'markup' && (ch === 91 /* SquareL */ || ch === 123 /* CurlyL */));\n}\nfunction isCloseBrace(ch, syntax) {\n    return ch === 41 /* RoundR */ || (syntax === 'markup' && (ch === 93 /* SquareR */ || ch === 125 /* CurlyR */));\n}\n\nfunction expandAbbreviation(abbr, config) {\n    const resolvedConfig = resolveConfig(config);\n    return resolvedConfig.type === 'stylesheet'\n        ? stylesheet(abbr, resolvedConfig)\n        : markup(abbr, resolvedConfig);\n}\n/**\n * Expands given *markup* abbreviation (e.g. regular Emmet abbreviation that\n * produces structured output like HTML) and outputs it according to options\n * provided in config\n */\nfunction markup(abbr, config) {\n    return stringify(parse(abbr, config), config);\n}\n/**\n * Expands given *stylesheet* abbreviation (a special Emmet abbreviation designed for\n * stylesheet languages like CSS, SASS etc.) and outputs it according to options\n * provided in config\n */\nfunction stylesheet(abbr, config) {\n    return css(parse$1(abbr, config), config);\n}\n\nexport default expandAbbreviation;\nexport { extractAbbreviation as extract, markup, parse as parseMarkup, parse$1 as parseStylesheet, convertSnippets as parseStylesheetSnippets, resolveConfig, stringify as stringifyMarkup, css as stringifyStylesheet, stylesheet };\n//# sourceMappingURL=emmet.es.js.map\n","/*\n\n    The MIT License (MIT)\n\n    Copyright (c) 2022-2023 Shadichy and contributors.\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation files\n    (the \"Software\"), to deal in the Software without restriction,\n    including without limitation the rights to use, copy, modify, merge,\n    publish, distribute, sublicense, and/or sell copies of the Software,\n    and to permit persons to whom the Software is furnished to do so,\n    subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\nimport emmet from \"emmet\"\n\nconst mimeTypes = {\n\t\".avif\": \"avif\",\n\t\".bmp\": \"bmp\",\n\t\".gif\": \"gif\",\n\t\".ico\": \"x-icon\",\n\t\".jpeg\": \"jpeg\",\n\t\".jpg\": \"jpeg\",\n\t\".png\": \"png\",\n\t\".svg\": \"svg+xml\",\n\t\".tif\": \"tiff\",\n\t\".tiff\": \"tiff\",\n\t\".webp\": \"webp\",\n}\n\nconst voidElements = [\n\t\"area\",\n\t\"base\",\n\t\"br\",\n\t\"col\",\n\t\"embed\",\n\t\"hr\",\n\t\"img\",\n\t\"input\",\n\t\"keygen\",\n\t\"link\",\n\t\"menuitem\",\n\t\"meta\",\n\t\"param\",\n\t\"source\",\n\t\"track\",\n\t\"wbr\",\n]\n\nvar isDense = false\n\nconst isArray = (o) => Object.prototype.toString.call(o) === \"[object Array]\",\n\tuseDense = () => (isDense = true)\n\nfunction parseElement(content) {\n\tif (typeof content === \"string\")\n\t\ttry {\n\t\t\treturn emmet.default(content, { options: {\n\t\t\t\t'output.indent': '',\n\t\t\t\t'output.newline': ''\n\t\t\t}})\n\t\t} catch (e) {\n\t\t\treturn content\n\t\t}\n\n\tif (!content.tag)\n\t\tcontent.tag = \"div\"\n\n\tlet htmlAtt = {},\n\t\tchild = \"\",\n\t\tclasslist = \"\"\n\n\tconst isVoid = voidElements.indexOf(content.tag) !== -1\n\n\tfunction subparse(k) {\n\t\tswitch (k) {\n\t\t\tcase \"panel\":\n\t\t\t\tif (!isVoid) child += parseElement({tag: \"nav\", ...content[k]})\n\t\t\t\tbreak\n\t\t\tcase \"header\":\n\t\t\tcase \"footer\":\n\t\t\t\tif (!isVoid) child += parseElement({tag: k, ...content[k]})\n\t\t\t\tbreak\n\t\t\tcase \"_\":\n\t\t\tcase \"content\":\n\t\t\t\tif (!isVoid)\n\t\t\t\t\ttypeof content[k] === \"string\" || !isArray(content[k])\n\t\t\t\t\t\t? (child += parseElement(content[k]))\n\t\t\t\t\t\t: content[k].forEach((o) => (child += parseElement(o)))\n\t\t\t\telse {\n\t\t\t\t\thtmlAtt[\"title\"] = content[k]\n\t\t\t\t\thtmlAtt[\"alt\"] = content[k]\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase \"style\":\n\t\t\t\tconst { classes, styles } = parseCss(content[k], content.tag == \"body\")\n\t\t\t\tclasses.forEach((c) => (classlist += \" \" + c))\n\t\t\t\tif (styles != \"\") htmlAtt[k] = styles\n\t\t\t\tbreak\n\t\t\tcase \"title\":\n\t\t\tcase \"desc\":\n\t\t\t\tif (content.tag != \"body\")\n\t\t\t\t\thtmlAtt[\"title\"] = content[k]\n\t\t\t\tif (isVoid) {\n\t\t\t\t\thtmlAtt[\"alt\"] = content[k]\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase \"class\":\n\t\t\t\tisArray(content[k])\n\t\t\t\t\t? content[k].forEach((c) => (classlist += c + \" \"))\n\t\t\t\t\t: (classlist = content[k])\n\t\t\t\tbreak\n\t\t\tcase \"#\":\n\t\t\tcase \"comment\":\n\t\t\t\tchild += `<!-- ${content[k]} -->`\n\t\t\t\tbreak\n\t\t\tcase \"stylesheet\":\n\t\t\tcase \"preview\":\n\t\t\tcase \"script\":\n\t\t\tcase \"keywords\":\n\t\t\tcase \"logo\":\n\t\t\tcase \"lang\":\n\t\t\tcase \"type\":\n\t\t\t\tif (content.tag == \"body\") break\n\t\t\tdefault:\n\t\t\t\thtmlAtt[k] = content[k]\n\t\t\t\tbreak\n\t\t}\n\t}\n\n\tisArray(content)\n\t\t? content.forEach((k) => subparse(k))\n\t\t: Object.keys(content).forEach((k) => subparse(k))\n\n\tif (classlist !== \"\") htmlAtt[\"class\"] = classlist.trimStart().trimEnd()\n\n\tlet htmlAttStr = \"\"\n\tObject.entries(htmlAtt).forEach(([k, v]) => (htmlAttStr += `${k}=\"${v}\"`))\n\n\treturn `<${content.tag}${htmlAttStr === \"\" ? \"\" : \" \" + htmlAttStr}${\n\t\tisVoid ? \"/>\" : `>${child}</${content.tag}>`\n\t}`\n}\n\nfunction parseCss(style, isBody) {\n\tif (typeof style === \"string\")\n\t\ttry {\n\t\t\treturn {\n\t\t\t\tclasses: [],\n\t\t\t\tstyles: emmet.default(style, { \n\t\t\t\t\ttype: \"stylesheet\", \n\t\t\t\t\toptions: {\n\t\t\t\t\t\t'output.indent': '',\n\t\t\t\t\t\t'output.newline': ''\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn { classes: [], styles: style }\n\t\t}\n\tlet classlist = [],\n\t\tcss = \"\"\n\n\tif (isDense) {\n\t\tif (!isBody) {\n\t\t\tif (!style.size) style.size = 1\n\t\t\tif (!style.type) style.type = \"box\"\n\t\t}\n\t\tObject.entries(style).forEach(([k, v]) => {\n\t\t\tswitch (k) {\n\t\t\t\tcase \"design\":\n\t\t\t\t\tclasslist.push(v)\n\t\t\t\t\tbreak\n\t\t\t\tcase \"type\":\n\t\t\t\t\tclasslist.push(v + style.size)\n\t\t\t\t\tbreak\n\t\t\t\tcase \"centerChild\":\n\t\t\t\t\tbreak\n\t\t\t\tcase \"border-radius\":\n\t\t\t\t\tcss += `${k}:${v == \"full\" ? \"100vw\" : v};`\n\t\t\t\t\tbreak\n\t\t\t\tcase \"size\":\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tcss += `${k}:${v};`\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t})\n\t} else Object.entries(style).forEach(([k, v]) => (css += `${k}:${v};`))\n\n\treturn { classes: classlist, styles: css }\n}\n\nfunction parse(data) {\n\tconst title = data.title || \"Document\",\n\t\ttype = data.type || \"website\",\n\t\tlang = data.lang || \"en\"\n\n\tlet logo = \"\"\n\tif (data.logo) {\n\t\tconst x = data.logo.match(/\\.([a-zA-Z0-9_]+)/g),\n\t\t\txt = mimeTypes[x[x.length - 1].toLowerCase()] || false\n\t\tlogo = `<link rel=\"shortcut icon\"href=\"${data.logo}\"${\n\t\t\txt ? `type=\"image/${xt}\"` : \"\"\n\t\t}/>`\n\t\tdelete data.logo\n\t}\n\n\tlet preview = \"\"\n\tif (data.preview) {\n\t\tpreview = `<meta property=\"og:image\"content=\"${data.preview}\"/><meta name=\"twitter:card\"content=\"summary_large_image\"/>`\n\t\tdelete data.preview\n\t}\n\n\tlet keywords = \"\"\n\tif (data.keywords) {\n\t\ttypeof data.keywords === \"string\"\n\t\t\t? (keywords = data.keywords)\n\t\t\t: data.keywords.forEach((k, i) => (keywords += (i == 0 ? \"\" : \", \") + k))\n\t\tkeywords = `<meta name=\"keywords\"content=\"${keywords}\"/>`\n\t\tdelete data.keywords\n\t}\n\n\tlet desc = \"\"\n\tif (data.desc) {\n\t\tdesc = `<meta property=\"description\"content=\"${data.desc}\"/><meta property=\"og:description\"content=\"${data.desc}\"/>`\n\t\tdelete data.desc\n\t}\n\n\tlet style = \"\"\n\tif (data.stylesheet) {\n\t\tlet styleContent = \"\"\n\t\tconst styleArray =\n\t\t\ttypeof data.stylesheet === \"string\" || !isArray(data.stylesheet)\n\t\t\t\t? [data.stylesheet]\n\t\t\t\t: data.stylesheet\n\t\tstyleArray.forEach((t) => {\n\t\t\tif (typeof t === \"string\") {\n\t\t\t\tif (!t) return\n\t\t\t\tconst x = t.match(/\\.s?[ca]{1}ss/gi)\n\t\t\t\tif (!x) {\n\t\t\t\t\tstyleContent += t\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tx[x.length - 1] != \"\" && t.endsWith(x[x.length - 1])\n\t\t\t\t\t? (style += `<link rel=\"stylesheet\"href=\"${t}\">`)\n\t\t\t\t\t: (styleContent += t)\n\t\t\t} else\n\t\t\t\tObject.entries(t).forEach(\n\t\t\t\t\t([k, v]) => (styleContent += `${k}{${parseCss(v).styles}}`)\n\t\t\t\t)\n\t\t})\n\t\tif (styleContent !== \"\") style += `<style>${styleContent}</style>`\n\t\tdelete data.stylesheet\n\t}\n\n\tlet script = \"\"\n\tif (data.script) {\n\t\tlet scriptContent = \"\"\n\t\tconst scriptArray =\n\t\t\ttypeof data.script !== \"object\"\n\t\t\t\t? [data.script]\n\t\t\t\t: isArray(data.script)\n\t\t\t\t? data.script\n\t\t\t\t: Object.values(data.script)\n\t\tscriptArray.forEach((t) => {\n\t\t\tif (typeof t === \"function\") scriptContent += t.toString()\n\t\t\telse {\n\t\t\t\tif (!t) return\n\t\t\t\tconst x = t.match(\n\t\t\t\t\t/\\.(([cm]?[tjlecs]+s[xm0-9]?)|((lit)?((iced)|(coffee)))|eg)/gi\n\t\t\t\t)\n\t\t\t\tif (!x) {\n\t\t\t\t\tscriptContent += t\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tx[x.length - 1] != \"\" && t.endsWith(x[x.length - 1])\n\t\t\t\t\t? (script += `<script language=\"javascript\"type=\"text/javascript\"src=\"${t}\"></script>`)\n\t\t\t\t\t: (scriptContent += t)\n\t\t\t}\n\t\t})\n\t\tif (scriptContent !== \"\")\n\t\t\tscript += `<script language=\"javascript\"type=\"text/javascript\">${scriptContent}</script>`\n\t\tdelete data.script\n\t}\n\n\treturn `<!DOCTYPE html><html lang=\"${lang}\"><head><meta charset=\"UTF-8\"/><meta http-equiv=\"X-UA-Compatible\"content=\"IE=edge\"/><meta name=\"viewport\"content=\"width=device-width,initial-scale=1.0\"/><title>${title}</title>${logo}${keywords}<meta property=\"og:title\"content=\"${title}\"/><meta property=\"og:type\"content=\"${type}\"/>${desc}${preview}${style}${script}</head>${parseElement(\n\t\t{tag: \"body\", ...data},\n\t\t\"body\"\n\t)}</html>`\n}\n\nexport default parse\nexport { parseElement as parseElement, parse as parse, useDense as useDense }\n"],"names":["isNumber","code","isAlpha","from","to","isAlphaNumericWord","isAlphaWord","isSpace","isWhiteSpace","isQuote","Scanner","constructor","str","start","end","length","this","string","pos","eof","limit","peek","charCodeAt","next","eat","match","ch","ok","eatWhile","backUp","n","current","substring","slice","error","message","ScannerError","Error","super","scanner","tokens","readable","size","consume","test","token","err","statements","options","result","type","elements","node","ctx","stack","element","group","push","isChildOperator","isSiblingOperator","isClimbOperator","pop","isGroupStart","isBracket","repeat","isRepeater","repeater","attr","elem","name","attributes","value","selfClose","jsx","isCapitalizedLiteral","isClassNameOperator","isElementName","elementName","isEmpty","text","getText","shortAttribute","attributeSet","isCloseOperator","concat","Array","isArray","isAttributeSetStart","attribute","isAttributeSetEnd","isOperator","expression","literal","quoted","isEquals","quote","single","allowBrackets","brackets","context","open","isTextStart","isOpen","Boolean","operator","isSingle","isLiteral","escaped","getToken","index","Number","consumePlaceholder","field","repeaterPlaceholder","reverse","base","parent","repeaterNumber","count","implicit","repeater$1","whiteSpace","isAllowedOperator","isElementName$1","isAllowedSpace","isAllowedRepeater","isQuote$1","bracketType","literal$1","op","operatorType","isOpenBracket","bracket","stream","operators","child","class","climb","id","equal","close","sibling","tokenVisitor","Literal","Quote","Bracket","Operator","Field","state","getVariable","RepeaterPlaceholder","i","repeaters","inserted","RepeaterNumber","lastIx","parentIx","Math","max","parentRepeater","String","WhiteSpace","stringify","urlRegex","emailRegex","convert","abbr","cleanText","textInserted","filter","s","trim","children","convertGroup","repeatGuard","maxRepeat","POSITIVE_INFINITY","_a","undefined","join","varValue","variables","deepest","deepestNode","last","insertText","href","startsWith","hrefAttribute","find","valueType","insertHref","convertStatement","original","Object","assign","items","isGroup","convertElement","target","stringifyName","stringifyValue","selfClosing","convertAttribute","some","isField","item","attachRepeater","implied","isBoolean","shift","boolean","arr","parseAbbreviation","abbreviation","source","tokenize","short","afterNegative","hasDecimal","prevPos","hasFloat","consumeNumber","rawValue","unit","numberValue","valueStart","color","alpha","isHex","colorAlpha","r","g","b","a","parseInt","parseColor","raw","createLiteral","colorValue","finished","stringValue","isIdentPrefix","isKeyword","shouldConsumeDashAfter","mergeTokens","consumeProperty","valueFragment","important","valueMode","isLiteral$1","t1","t2","isFunctionStart","isValueDelimiter","isImportant","consumeValue","isFragmentDelimiter","inArgument","args","isValue","consumeArguments","arguments","isCloseBracket","isArgumentDelimiter","isBracket$1","parse","tokenScanner","property","parser","mergeValue","prev","glue","append","t","mergeDeclarations","dest","src","config","findDeepest","isNode","walkResolve","resolve","resolved","mergeNodes","createOutputStream","level","offset","line","column","_push","processText","pushString","lines","split","splitByLines","il","pushNewline","indent","baseIndent","pushIndent","pushField","placeholder","attrName","strCase","attrQuote","isBooleanAttribute","includes","toLowerCase","isInline","inlineElements","toUpperCase","elementMap","p","ul","ol","table","tr","tbody","thead","tfoot","colgroup","select","optgroup","audio","video","object","map","resolveImplicitTag","ancestors","getParentElement","contextName","parentName","vocabularies","ru","common","words","sp","latin","reLorem","rand","floor","random","sample","len","iterations","min","sentence","word","val","insertCommas","hasComma","totalCommas","paragraph","dict","wordCount","startWithCommon","totalWords","rename","isAllowed","reElement","reModifier","blockCandidates1","className","blockCandidates2","bem","data","getBEMData","classNames","cl","ix","indexOf","uniqueClass","block","findBlockName","updateClass","expandClassNames","path","m","prefix","originalClass","getBlockName","arrClassNames","expandShortNotation","_bem","classValue","parseBEM","depth","getBEMDataFromContext","walk$1","visitor","callback","forEach","createWalkState","out","caret","isSnippet","isInlineElement","pushTokens","largestIndex","shouldOutputAttribute","template","namePos","afterPos","isTokenStart","isToken","before","after","shouldComment","comment","enabled","trigger","output","attrs","htmlTagRegex","html","createCommentState","format","shouldFormat","getIndent","tagName","commentNodeBefore","pushAttribute","pushSnippet","innerFormat","hasNewline","matches","exec","startsWithBlockTag","commentNodeAfter","lQuote","rQuote","fieldIx","findIndex","trimLeft","adjacentInline","indentFormat","element$1","primary","secondary","isPrimaryAttribute","collectAttributes","shouldFormat$1","beforeName","afterName","replace","pushPrimaryAttributes","beforeAttribute","booleanValue","glueAttribute","afterAttribute","pushSecondaryAttributes","splitByLines$1","lineLengths","maxLength","valueLength","beforeTextLine","afterTextLine","pushValue","formatters","haml","slim","pug","oldTextValue","parseOpt","parse$2","reversed","snippet","snippets","snippetAbbr","topNode","resolveSnippets","fn","walk","transform","implicitTag","lookup","mergeAttributes","db","minWordCount","findRepeater","lorem","syntax","xsl","reProperty","opt","createSnippet","key","keywords","parsed","parseValue","cssVal","collectKeywords","dependencies","snippetsSort","parse$3","isProperty","v","scoreMatch","str1","str2","partialMatch","str1Len","str2Len","minLength","j","score","ch1","ch2","found","acronym","delta","sum","shortHex","isShortHex","toShortHex","toHex","asHex","values","frac","asRGB","num","digits","toFixed","hex","toString","pad","isJSON","_","letter","getSingleNumeric","getQuote","outputValue","propertyValue","outputImportant","outputToken","separator","prevEnd","gradientName","parse$1","cache","stylesheetSnippets","keys","sort","cur","nest","convertSnippets","isValueScope","filteredSnippets","getSnippetsForScope","resolveNode","gradientFn","cssValue","resolveGradient","propName","resolveValueKeywords","findBestMatch","inlineValue","lastPos","getUnmatchedPart","kw","resolveKeyword","defaultValue","hasField","wrapWithField","resolveAsProperty","reField","inputValue","tail","resolveAsSnippet","aliases","unitless","resolveNumericValue","minScore","matchedItem","maxScore","getScoringPart","ref","dep","q","defaultSyntaxes","markup","stylesheet","defaultConfig","lang","locale","charset","indentation","newline","e","x","syntaxConfig","parseSnippets","basefont","br","frame","hr","bdo","col","link","meta","style","script","img","picture","iframe","embed","param","area","form","label","input","inp","isindex","textarea","marquee","keygen","command","bq","fig","figc","pic","ifr","emb","obj","cap","colg","fst","btn","optg","tarea","leg","sect","art","hdr","ftr","adr","dlg","prog","mn","tem","fset","datag","datal","kg","det","cmd","doc","c","xhtml","xml","call","ap","api","imp","inc","ot","if","par","pare","var","vare","wp","cp","co","tex","com","msg","fall","nam","pres","strip","proc","choose","ac","ai","anim","animdel","animdir","animdur","animfm","animic","animn","animps","animtf","as","bd","bdb","bdbc","bdbi","bdbk","bdbli","bdblrs","bdbri","bdbrrs","bdbs","bdbw","bdc","bdci","bdcl","bdf","bdi","bdl","bdlc","bdlen","bdli","bdls","bdlw","bdr","bdrc","bdri","bdrs","bdrst","bdrw","bds","bdsp","bdt","bdtc","bdti","bdtli","bdtlrs","bdtri","bdtrrs","bdts","bdtw","bdw","bfv","bg","bga","bgbk","bgc","bgcp","bgi","bgo","bgp","bgpx","bgpy","bgr","bgsz","bxsh","bxsz","cr","cra","cm","cnt","coi","colm","colmc","colmf","colmg","colmr","colmrc","colmrs","colmrw","colms","colmw","cor","cps","d","ec","f","fd","fef","fem","femp","fems","ff","fft","ffa","ffv","fl","fs","fsm","fv","fvs","fw","fx","fxb","fxd","fxf","fxg","fxsh","fxw","fsz","fsza","gtc","gtr","gta","gt","gg","gcg","grg","gac","gar","gaf","gd","gc","gcs","gce","gr","grs","gre","ga","h","jc","ji","js","l","lg","lh","lis","lisi","lisp","list","lts","mah","mar","maw","mb","mih","mir","miw","ml","mr","mt","olc","olo","ols","olw","ord","ori","orp","ov","ovs","ovx","ovy","pb","pgba","pgbb","pgbi","pl","pr","pt","qen","qru","rsz","ta","tal","tbl","td","te","th","ti","tj","tov","trf","trfo","trfs","trs","trsde","trsdu","trsp","trstf","tsh","tt","tw","us","va","w","whs","whsc","wid","wm","wob","wos","wow","z","zom","sass","stylus","k","mergedData","globals","typeDefaults","typeOverride","syntaxDefaults","syntaxOverride","expandAbbreviation","resolvedConfig","resolveConfig","css","mimeTypes","voidElements","isDense","o","prototype","parseElement","content","emmet","default","tag","htmlAtt","classlist","isVoid","subparse","classes","styles","parseCss","trimStart","trimEnd","htmlAttStr","entries","isBody","title","logo","xt","preview","desc","styleContent","endsWith","scriptContent"],"mappings":"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"}